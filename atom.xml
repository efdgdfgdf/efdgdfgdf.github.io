<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CaptLin&#39;s Blog🍨</title>
  
  
  <link href="https://www.dp2002.top/atom.xml" rel="self"/>
  
  <link href="https://www.dp2002.top/"/>
  <updated>2023-02-02T13:09:00.000Z</updated>
  <id>https://www.dp2002.top/</id>
  
  <author>
    <name>Sunshine</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python基础知识</title>
    <link href="https://www.dp2002.top/posts/f1a5/"/>
    <id>https://www.dp2002.top/posts/f1a5/</id>
    <published>2023-01-29T02:45:00.000Z</published>
    <updated>2023-02-02T13:09:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Python知识点（一）-运算符和表达式"><a href="#Python知识点（一）-运算符和表达式" class="headerlink" title="Python知识点（一）  运算符和表达式"></a>Python知识点（一）  运算符和表达式</h2><blockquote><p>“+”运算符不支持不同内置类型的对象之间相加或连接。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="string">&#x27;A&#x27;</span> + <span class="number">1</span>                            <span class="comment">#不支持字符与数字相加，抛出异常</span></span><br><span class="line">TypeError: can only concatenate <span class="built_in">str</span> (<span class="keyword">not</span> <span class="string">&quot;int&quot;</span>) to <span class="built_in">str</span></span><br></pre></td></tr></table></figure><blockquote><p>“<em>”运算符 §列表、字符串或元组等类型变量与整数进行“</em>”运算时，表示<strong>对内容进行重复</strong>并返回重复后的新对象。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="string">&#x27;a&#x27;</span> * <span class="number">10</span>                    <span class="comment">#字符串重复</span></span><br><span class="line"><span class="string">&#x27;aaaaaaaaaa&#x27;</span></span><br><span class="line"> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] * <span class="number">3</span>                 <span class="comment">#列表重复</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"> (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>) * <span class="number">3</span>                 <span class="comment">#元组重复</span></span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><blockquote><p>“&#x2F;”和“&#x2F;&#x2F;”分别表示除法和整除运算。</p></blockquote><blockquote><p>同一性测试运算符（identity comparison）is用来测试两个对象是否引用同一个地址，如果是则返回True，否则返回False。<strong>如果两个对象引用了同一个对象，二者具有相同的内存地址。</strong></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> 3 is 3</span><br><span class="line">True</span><br><span class="line"></span><br><span class="line"> x = [300, 300, 300]</span><br><span class="line"> x[0] is x[1]        #基于值的内存管理，同一个值在内存中只有一份</span><br><span class="line">True</span><br><span class="line"></span><br><span class="line"> x = [1, 2, 3]</span><br><span class="line"> y = [1, 2, 3]</span><br><span class="line"> x is y              #上面形式创建的x和y不是同一个列表对象</span><br><span class="line">False</span><br></pre></td></tr></table></figure><blockquote><p>Python不支持++和–运算符，只是两个连续的加号和减号。</p></blockquote><blockquote><p>and和or具有惰性求值特点，只计算必须计算的表达式。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span>&gt;<span class="number">5</span> <span class="keyword">or</span> a&gt;<span class="number">3</span>           <span class="comment"># 3&gt;5的值为False，所以需要计算后面表达式</span></span><br><span class="line">NameError: name <span class="string">&#x27;a&#x27;</span> <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>&lt;<span class="number">5</span> <span class="keyword">or</span> a&gt;<span class="number">3</span>           <span class="comment">#3&lt;5的值为True，不需要计算后面表达式</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><h2 id="Python知识点（二）-常用内置函数"><a href="#Python知识点（二）-常用内置函数" class="headerlink" title="Python知识点（二）  常用内置函数"></a>Python知识点（二）  常用内置函数</h2><h3 id="eval"><a href="#eval" class="headerlink" title="eval()"></a>eval()</h3><blockquote><p>去掉参数最外侧引号并执行余下语句的函数</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">eval</span>(<span class="string">&quot;1&quot;</span>)</span><br><span class="line"><span class="number">1</span> </span><br><span class="line"></span><br><span class="line"><span class="built_in">eval</span>(<span class="string">&quot;1+2&quot;</span>)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">eval</span>(<span class="string">&#x27;print(&quot;Hello&quot;)&#x27;</span>)</span><br><span class="line">Hello</span><br></pre></td></tr></table></figure><h3 id="divmod-x-y"><a href="#divmod-x-y" class="headerlink" title="divmod(x, y)"></a>divmod(x, y)</h3><blockquote><p>计算整商和余数，返回元组(x&#x2F;&#x2F;y, x%y)</p></blockquote><h3 id="range"><a href="#range" class="headerlink" title="range()"></a>range()</h3><blockquote><p>语法格式为range([start,] end [, step] )，返回具有惰性求值特点的range对象，其中包含<strong>左闭右开区间</strong>[start,end)内以step为步长的整数。</p></blockquote><h3 id="map-func-iterables"><a href="#map-func-iterables" class="headerlink" title="map(func, *iterables)"></a>map(func, *iterables)</h3><blockquote><p>把一个可调用对象func依次映射到一个或多个可迭代对象的每个元素上，并返回一个可迭代的map对象作为结果，map对象中每个元素是原可迭代对象中元素经过可调用对象func处理后的结果。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">x, y</span>):            <span class="comment">#可以接收2个参数的函数</span></span><br><span class="line">    <span class="keyword">return</span> x+y</span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>(<span class="built_in">map</span>(add, <span class="built_in">range</span>(<span class="number">5</span>), <span class="built_in">range</span>(<span class="number">5</span>,<span class="number">10</span>)))  <span class="comment">#把双参数函数映射到两个序列上</span></span><br><span class="line"></span><br><span class="line">[<span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">13</span>]  <span class="comment"># 输出结果</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="sorted-key-x3D-None-reverse-x3D-False"><a href="#sorted-key-x3D-None-reverse-x3D-False" class="headerlink" title="sorted(key&#x3D;None,reverse&#x3D;False)"></a>sorted(key&#x3D;None,reverse&#x3D;False)</h3><blockquote><p>返回排序后的列表，参数key用来指定排序规则或依据，参数reverse用来指定升序或降序，默认为升序。</p></blockquote><h3 id="filter-function-or-None-iterable"><a href="#filter-function-or-None-iterable" class="headerlink" title="filter(function or None, iterable)"></a>filter(function or None, iterable)</h3><blockquote><p>将一个单参数可调用对象作用到一个可迭代对象上，返回其中使得可调用对象返回值等价于True的那些元素组成的filter对象，如果指定filter()函数第一个参数为None，则返回可迭代对象中等价于True的元素。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">seq = [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;x41&#x27;</span>, <span class="string">&#x27;?!&#x27;</span>, <span class="string">&#x27;***&#x27;</span>]</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> x.isalnum()              <span class="comment">#测试是否为字母或数字</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">filter</span>(func, seq)                   <span class="comment">#返回filter对象</span></span><br><span class="line">&lt;<span class="built_in">filter</span> <span class="built_in">object</span> at <span class="number">0x000000000305D898</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>(<span class="built_in">filter</span>(func, seq))             <span class="comment">#把filter对象转换为列表</span></span><br><span class="line">[<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;x41&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>(<span class="built_in">filter</span>(<span class="built_in">str</span>.isalnum, seq))      <span class="comment">#等价的用法</span></span><br><span class="line">[<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;x41&#x27;</span>]</span><br><span class="line"></span><br><span class="line">data = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">20</span>))</span><br><span class="line">filterObject = <span class="built_in">filter</span>(<span class="keyword">lambda</span> x:x%<span class="number">2</span>==<span class="number">1</span>, data)    <span class="comment">#过滤，只留下所有奇数</span></span><br><span class="line"></span><br><span class="line">filterObject</span><br><span class="line">&lt;<span class="built_in">filter</span> <span class="built_in">object</span> at <span class="number">0x000001D602B85828</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="number">3</span> <span class="keyword">in</span> filterObject            <span class="comment">#3以及3之前的元素都访问过了</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>(filterObject)           <span class="comment">#现在所有元素都访问过了</span></span><br><span class="line">[<span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">15</span>, <span class="number">17</span>, <span class="number">19</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>(filterObject)           <span class="comment">#filterObject中不再包含任何元素，因为filter对象具有惰性求值的特点</span></span><br><span class="line">[]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="reduce-function-sequence-initial"><a href="#reduce-function-sequence-initial" class="headerlink" title="reduce(function, sequence[, initial])"></a>reduce(function, sequence[, initial])</h3><blockquote><p>可以将一个接收2个参数的可调用对象以<strong>迭代累积</strong>的方式从左到右依次作用到一个可迭代对象的所有元素上，并且允许指定一个初始值。在Python 3.x中reduce()不是内置函数，需要从标准库functools中导入再使用。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line">seq = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>))     <span class="comment"># 数据</span></span><br><span class="line">reduce(<span class="keyword">lambda</span> x, y: x+y, seq)  <span class="comment"># 累加并返回结果 输出结果 45</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://img1.imgtp.com/2023/02/03/M937iBYM.png" alt="image-20230116211838466"></p><h3 id="round-number-ndigits-x3D-None"><a href="#round-number-ndigits-x3D-None" class="headerlink" title="round(number, ndigits&#x3D;None)"></a>round(number, ndigits&#x3D;None)</h3><blockquote><p>对number进行四舍五入，最终结果保留ndigits位小数。</p></blockquote><h3 id="enumerate"><a href="#enumerate" class="headerlink" title="enumerate()"></a>enumerate()</h3><blockquote><p>函数用来枚举可迭代对象中的元素，返回可迭代的enumerate对象，其中每个元素都是包含索引和值的元组。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>(<span class="built_in">enumerate</span>(<span class="string">&#x27;abcd&#x27;</span>))            <span class="comment">#枚举字符串中的元素</span></span><br><span class="line">[(<span class="number">0</span>, <span class="string">&#x27;a&#x27;</span>), (<span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>), (<span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>), (<span class="number">3</span>, <span class="string">&#x27;d&#x27;</span>)]</span><br></pre></td></tr></table></figure><h3 id="bin-、oct-、hex"><a href="#bin-、oct-、hex" class="headerlink" title="bin()、oct()、hex()"></a>bin()、oct()、hex()</h3><blockquote><p>将**<u>整数</u>**转换为二进制、八进制和十六进制形式。</p></blockquote><h3 id="zip"><a href="#zip" class="headerlink" title="zip()"></a><strong>zip()</strong></h3><blockquote><p>函数用来把多个可迭代对象中对应位置上的元素组合到一起，返回一个可迭代的zip对象，其中每个元素都是包含原来的多个可迭代对象对应位置上元素的元组，如同拉拉链一样。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>(<span class="built_in">zip</span>(<span class="string">&#x27;abcd&#x27;</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]))  <span class="comment"># 输出结果  [(&#x27;a&#x27;, 1), (&#x27;b&#x27;, 2), (&#x27;c&#x27;, 3)]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>(<span class="built_in">zip</span>(<span class="string">&#x27;123&#x27;</span>, <span class="string">&#x27;abc&#x27;</span>, <span class="string">&#x27;,.!&#x27;</span>))  <span class="comment"># 输出结果  [(&#x27;1&#x27;, &#x27;a&#x27;, &#x27;,&#x27;), (&#x27;2&#x27;, &#x27;b&#x27;, &#x27;.&#x27;), (&#x27;3&#x27;, &#x27;c&#x27;, &#x27;!&#x27;)]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以看到结果列表中的每个成员都是元组类型</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="最后注意："><a href="#最后注意：" class="headerlink" title="最后注意："></a>最后注意：</h3><blockquote><p>map、filter、enumerate、zip等对象不仅具有惰性求值的特点，还有另外一个特点：访问过的元素不可再次访问。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="built_in">map</span>(<span class="built_in">str</span>, <span class="built_in">range</span>(<span class="number">10</span>))   </span><br><span class="line"><span class="built_in">list</span>(x)</span><br><span class="line">[<span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;9&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>(x)</span><br><span class="line">[]   <span class="comment"># 失效了</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="阶段练习"><a href="#阶段练习" class="headerlink" title="阶段练习"></a>阶段练习</h2><p>用户输入一个三位自然数，计算并输出其佰位、十位和个位上的数字。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一种</span></span><br><span class="line">x = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;请输入一个三位数：&#x27;</span>))</span><br><span class="line">a, b = <span class="built_in">divmod</span>(x, <span class="number">100</span>)</span><br><span class="line">b, c = <span class="built_in">divmod</span>(b, <span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(a, b, c)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二种</span></span><br><span class="line">x = <span class="built_in">input</span>(<span class="string">&#x27;请输入一个三位数：&#x27;</span>)</span><br><span class="line">a, b, c = <span class="built_in">map</span>(<span class="built_in">int</span>, x)</span><br><span class="line"><span class="built_in">print</span>(a, b, c)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第三种  不限位数</span></span><br><span class="line">x = <span class="built_in">input</span>(<span class="string">&#x27;请输入一个n位自然数：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(*<span class="built_in">map</span>(<span class="built_in">int</span>, x))</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>任意输入三个英文单词，按字典顺序输出。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="built_in">input</span>(<span class="string">&#x27;x,y,z=&#x27;</span>)</span><br><span class="line">x, y, z = <span class="built_in">sorted</span>(s.split(<span class="string">&#x27;,&#x27;</span>))   <span class="comment"># 逗号分隔</span></span><br><span class="line"><span class="built_in">print</span>(x, y, z)</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h2 id="Python知识点（三）-Python序列"><a href="#Python知识点（三）-Python序列" class="headerlink" title="Python知识点（三）  Python序列"></a>Python知识点（三）  Python序列</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><img src="https://img1.imgtp.com/2023/02/03/hedBwkgM.png" alt="image-20230119150122468"></p><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><h4 id="列表增加"><a href="#列表增加" class="headerlink" title="列表增加"></a>列表增加</h4><blockquote><p>使用列表对象的extend()方法可以将另一个可迭代对象的所有元素添加至该列表对象尾部。通过extend()方法来增加列表元素也不改变其内存首地址，属于<strong>原地操作</strong>。</p></blockquote><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">aList = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br><span class="line">aList.extend([<span class="number">11</span>,<span class="number">13</span>])</span><br><span class="line">aList</span><br><span class="line">[<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">13</span>]</span><br><span class="line"></span><br><span class="line">aList.extend((<span class="number">15</span>,<span class="number">17</span>))</span><br><span class="line">aList</span><br><span class="line">[<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">15</span>, <span class="number">17</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>使用列表对象的insert()方法将元素添加至列表的指定位置。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">aList.insert(<span class="number">3</span>, <span class="number">6</span>)                <span class="comment">#在下标为3的位置插入元素6</span></span><br><span class="line">aList</span><br><span class="line">[<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">15</span>, <span class="number">17</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>当使用*运算符将包含列表的列表重复并创建新列表时，并不是复制子列表值，而是复制已有元素的引用。因此，当修改其中一个值时，相应的引用也会被修改。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">x = [[<span class="literal">None</span>] * <span class="number">2</span>] * <span class="number">3</span></span><br><span class="line">x</span><br><span class="line">[[<span class="literal">None</span>, <span class="literal">None</span>], [<span class="literal">None</span>, <span class="literal">None</span>], [<span class="literal">None</span>, <span class="literal">None</span>]]</span><br><span class="line"></span><br><span class="line">x[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">5</span></span><br><span class="line">x</span><br><span class="line">[[<span class="number">5</span>, <span class="literal">None</span>], [<span class="number">5</span>, <span class="literal">None</span>], [<span class="number">5</span>, <span class="literal">None</span>]]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="列表删除"><a href="#列表删除" class="headerlink" title="列表删除"></a>列表删除</h4><blockquote><p>del命令</p><p>pop()方法删除并返回<em>指定位置</em>（默认为最后一个）</p><p>remove()方法删除首次出现的指定元素，如果列表中不存在要删除的元素，则抛出异常。</p><p>注：列表有自动内存管理功能。在删除列表元素时，Python会自动对列表内存进行收缩并移动列表元素以保证所有元素之间没有空隙，增加列表元素时也会自动扩展内存并对元素进行移动以保证元素之间没有空隙。每当插入或删除一个元素之后，该元素位置后面所有元素的索引就都改变了。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">正确的删除代码：</span><br><span class="line">x = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(x)-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>):         <span class="comment">#从后往前删</span></span><br><span class="line">    <span class="keyword">if</span> x[i]==<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">del</span> x[i]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="列表切片"><a href="#列表切片" class="headerlink" title="列表切片"></a>列表切片</h4><blockquote><p>切片返回的是浅复制。所谓浅复制，是指生成一个新的列表，并且把原列表中所选元素的引用都复制到新列表中。如果原列表中只包含<strong>整数、实数、复数等基本类型或元组、字符串这样的不可变类型</strong>的数据，一般是没有问题的。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">aList = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>]</span><br><span class="line">bList = aList[::]                 <span class="comment">#切片，浅复制</span></span><br><span class="line">aList == bList                    <span class="comment">#两个列表的元素完全一样</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line">aList <span class="keyword">is</span> bList                    <span class="comment">#但不是同一个对象</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="built_in">id</span>(aList) == <span class="built_in">id</span>(bList)            <span class="comment">#内存地址不一样</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line">bList[<span class="number">1</span>] = <span class="number">8</span>                      <span class="comment">#修改其中一个不会影响另一个</span></span><br><span class="line">bList</span><br><span class="line">[<span class="number">3</span>, <span class="number">8</span>, <span class="number">7</span>]</span><br><span class="line">aList</span><br><span class="line">[<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>]</span><br></pre></td></tr></table></figure><blockquote><p>如果原列表中包含列表之类的可变数据类型，由于浅复制时只是把子列表的引用复制到新列表中，这样的话修改任何一个都会影响另外一个。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">aList = [<span class="number">3</span>, [<span class="number">5</span>], <span class="number">7</span>]        <span class="comment">#列表aList中包含可变的列表对象</span></span><br><span class="line">bList = aList[:]           <span class="comment">#切片</span></span><br><span class="line">bList[<span class="number">1</span>].append(<span class="number">6</span>)         <span class="comment">#调用子列表的append()方法，这个方法是原地操作的</span></span><br><span class="line"></span><br><span class="line">bList</span><br><span class="line">[<span class="number">3</span>, [<span class="number">5</span>, <span class="number">6</span>], <span class="number">7</span>]</span><br><span class="line"></span><br><span class="line">aList                      <span class="comment">#aList受到影响</span></span><br><span class="line">[<span class="number">3</span>, [<span class="number">5</span>, <span class="number">6</span>], <span class="number">7</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>标准库copy中的deepcopy()函数实现深复制。所谓深复制，是指对原列表中的元素进行递归，把所有的值都复制到新列表中，对嵌套的子列表不再是复制引用。新列表和原列表是互相独立，<strong>修改任何一个都不会影响另外一个</strong>。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">aList = [<span class="number">3</span>, [<span class="number">5</span>], <span class="number">7</span>]</span><br><span class="line"><span class="keyword">import</span> copy</span><br><span class="line">bList = copy.deepcopy(aList) <span class="comment">#深赋值，递归复制，直到遇到可哈希对象</span></span><br><span class="line">                                 <span class="comment">#aList和bList完全独立，互相不影响</span></span><br><span class="line">aList == bList</span><br><span class="line"><span class="literal">True</span></span><br><span class="line">aList <span class="keyword">is</span> bList</span><br><span class="line"><span class="literal">False</span></span><br><span class="line">bList[<span class="number">1</span>].append(<span class="number">6</span>)           <span class="comment">#修改bList不会影响aList</span></span><br><span class="line">bList</span><br><span class="line">[<span class="number">3</span>, [<span class="number">5</span>, <span class="number">6</span>], <span class="number">7</span>]</span><br><span class="line">aList</span><br><span class="line">[<span class="number">3</span>, [<span class="number">5</span>], <span class="number">7</span>]</span><br></pre></td></tr></table></figure><p>以下这张图深刻地解释了切片复制的原理：不可变类型数据不影响（指向不同的内存地址），可变类型数据影响（指向相同的内存地址）</p><p><img src="https://img1.imgtp.com/2023/02/03/kuDTjk64.png" alt="image-20230119162208000"></p><h4 id="列表排序"><a href="#列表排序" class="headerlink" title="列表排序"></a>列表排序</h4><blockquote><p>sort()方法进行原地排序</p><p>sorted()对列表进行排序并返回<u>新列表</u>。</p><p>reverse()方法将元素原地逆序。</p><p>reversed()对列表元素进行逆序排列并返回<u>迭代器</u>对象。</p><p>注：sort 是应用在 list 上的方法，sorted 可以对<strong>所有可迭代的对象</strong>进行排序操作。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">aList = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">15</span>, <span class="number">17</span>]</span><br><span class="line">aList.sort()                          <span class="comment">#默认是升序排序</span></span><br><span class="line">aList.sort(reverse=<span class="literal">True</span>)              <span class="comment">#降序排序</span></span><br><span class="line">aList.sort(key=<span class="keyword">lambda</span> x:<span class="built_in">len</span>(<span class="built_in">str</span>(x)))  <span class="comment">#按转换成字符串的长度排序</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">sorted</span>(aList)                          <span class="comment">#升序排序，默认是按字母的ascii编码顺序</span></span><br><span class="line"><span class="built_in">sorted</span>(aList,reverse=<span class="literal">True</span>)             <span class="comment">#降序排序</span></span><br><span class="line"></span><br><span class="line">aList.reverse()            <span class="comment"># 原地逆序</span></span><br><span class="line"></span><br><span class="line">newList = <span class="built_in">reversed</span>(aList)            <span class="comment">#返回reversed对象</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> newList:</span><br><span class="line">    <span class="built_in">print</span>(i, end=<span class="string">&#x27; &#x27;</span>)                  <span class="comment">#输出结果  17 15 13 11 9 7 6 5 4 3</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">t1 = <span class="string">&#x27;gadfsf&#x27;</span></span><br><span class="line">t2 = (<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">s1 = <span class="built_in">sorted</span>(t1)             <span class="comment"># 对不可变序列的元组和字符串进行排序</span></span><br><span class="line">s2 = <span class="built_in">sorted</span>(t2)</span><br><span class="line">s1                         <span class="comment"># 输出结果  [&#x27;a&#x27;, &#x27;d&#x27;, &#x27;f&#x27;, &#x27;f&#x27;, &#x27;g&#x27;, &#x27;s&#x27;]</span></span><br><span class="line">s2                         <span class="comment"># 输出结果  [1, 2, 3]</span></span><br><span class="line"><span class="comment"># 可以看出排序后返回的是一个新列表</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure><h4 id="用于序列操作的常用内置函数"><a href="#用于序列操作的常用内置函数" class="headerlink" title="用于序列操作的常用内置函数"></a>用于序列操作的常用内置函数</h4><p>any(iterable)</p><blockquote><p>参数<br>        iterable – 元组或列表<br>返回值<br>        如果都为空、0、false，则返回false，如果不都为空、0、false，则返回true。有点类似于或运算（or）</p></blockquote><p>all(iterable)</p><blockquote><p>参数<br>iterable – 元组或列表。<br>返回值<br>如果iterable的所有元素不为0、’’、False或者iterable为空，all(iterable)返回True，否则返回False；</p><p>注意：<strong>空元组、空列表返回值为True</strong>，这里要特别注意。</p></blockquote><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><blockquote><p>len(列表)：返回列表中的元素个数</p><p>max(列表)、 min(列表)：返回列表中的最大或最小元素</p><p>sum(列表)：对列表的元素进行求和运算</p><p>zip()函数返回可迭代的zip对象</p><p>enumerate(列表):枚举列表元素，返回枚举对象，其中每个元素为包含下标和值的元组。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">aList = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">bList = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">cList = <span class="built_in">zip</span>(aList, bList)         <span class="comment">#返回zip对象</span></span><br><span class="line">cList</span><br><span class="line">&lt;<span class="built_in">zip</span> <span class="built_in">object</span> at <span class="number">0x0000000003728908</span>&gt;</span><br><span class="line"><span class="built_in">list</span>(cList)                       <span class="comment">#把zip对象转换成列表</span></span><br><span class="line">[(<span class="number">1</span>, <span class="number">4</span>), (<span class="number">2</span>, <span class="number">5</span>), (<span class="number">3</span>, <span class="number">6</span>)]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="string">&#x27;abcdef&#x27;</span>):</span><br><span class="line">    <span class="built_in">print</span>(item)</span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">(<span class="number">0</span>, <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">(<span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">(<span class="number">3</span>, <span class="string">&#x27;d&#x27;</span>)</span><br><span class="line">(<span class="number">4</span>, <span class="string">&#x27;e&#x27;</span>)</span><br><span class="line">(<span class="number">5</span>, <span class="string">&#x27;f&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h3><h4 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h4><p>tuple一旦初始化就不能修改，这个tuple不能变了，它也没有append()，insert()这样的方法。其他获取元素的方法和list是一样的，你可以正常地使用classmates[0]，classmates[-1]，但不能赋值成另外的元素。</p><p>tuple的陷阱：当你定义一个tuple时，在定义的时候，tuple的元素就必须被确定下来。</p><p>只有1个元素的tuple定义时必须加一个逗号，来消除歧义，以免你误解成数学计算意义上的括号。</p><p>tuple所谓的“不变”是说，tuple的每个元素，指向永远不变。</p><h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><h4 id="字典元素的读取"><a href="#字典元素的读取" class="headerlink" title="字典元素的读取"></a>字典元素的读取</h4><p>使用字典对象的items()方法可以返回字典的元素。<br>使用字典对象的keys()方法可以返回字典的“键”。<br>使用字典对象的values()方法可以返回字典的“值”。</p><h2 id="Python知识点（四）-选择与循环"><a href="#Python知识点（四）-选择与循环" class="headerlink" title="Python知识点（四）  选择与循环"></a>Python知识点（四）  选择与循环</h2><p>例3-7  输出所有3位“水仙花数”。所谓n位水仙花数是指1个n位的十进制数，其各位数字的n次方之和等于该数本身。例如：153是水仙花数，因为153 &#x3D; 13 + 53 + 33 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>, <span class="number">1000</span>):</span><br><span class="line">    bai, shi, ge = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">str</span>(i))</span><br><span class="line">    <span class="keyword">if</span> ge**<span class="number">3</span> + shi**<span class="number">3</span> + bai**<span class="number">3</span> == i:</span><br><span class="line">        <span class="built_in">print</span>(i)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>, <span class="number">1000</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">sum</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x:<span class="built_in">int</span>(x)**<span class="number">3</span>, <span class="built_in">str</span>(num))) == num:</span><br><span class="line">        <span class="built_in">print</span>(num)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 扩展到n位水仙花数：</span></span><br><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;请输入位数：&#x27;</span>))</span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>**(n-<span class="number">1</span>), <span class="number">10</span>**n):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">sum</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> i: <span class="built_in">int</span>(i)**n, <span class="built_in">str</span>(num))) == num:</span><br><span class="line">        <span class="built_in">print</span>(num)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>例3-12  鸡兔同笼问题。假设共有鸡、兔30只，脚90只，求鸡、兔各有多少只。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ji <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">31</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="number">2</span>*ji + (<span class="number">30</span>-ji)*<span class="number">4</span> == <span class="number">90</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;ji:&#x27;</span>, ji, <span class="string">&#x27; tu:&#x27;</span>, <span class="number">30</span>-ji)</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><p>例3-17  计算前n个自然数的阶乘之和1!+2!+3!+…+n!的值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func3</span>(<span class="params">n</span>):</span><br><span class="line">    result = <span class="number">0</span></span><br><span class="line">    t = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">        t = t * i</span><br><span class="line">        result = result+t</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Python知识点（五）-字符串与正则表达式"><a href="#Python知识点（五）-字符串与正则表达式" class="headerlink" title="Python知识点（五）  字符串与正则表达式"></a>Python知识点（五）  字符串与正则表达式</h2><h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><ul><li><p>python3默认的字符集是 unicode，也就是str 类型，包含了全世界所有的字符</p></li><li><p>unicode只是一种编码规范，是一个字符集。</p></li><li><p>UTF-8字符集比GBK字符集大很多，有些字符没有对应的GBK编码。</p></li></ul><p>注：utf-8和gbk编码之间不能之间转换，要在unicode之间过个场才能转换。</p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><blockquote><p>str.lower() 或 str.upper()方法返回字符串的副本，全部字符小写&#x2F;大写。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;AbCdEfGh&quot;</span>.lower() <span class="comment"># 结果为 &quot;abcdefgh&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>str.split(sep&#x3D;None)方法返回一个列表，由str根据sep被分隔的字段组成。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;A,B,C&quot;</span>.split(<span class="string">&quot;,&quot;</span>)  <span class="comment"># 结果为 [&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;]</span></span><br></pre></td></tr></table></figure><blockquote><p>str.strip() 方法用于移除字符串头尾指定的字符（默认为空格或换行符）或字符序列。</p></blockquote><p><strong>注意：</strong>该方法只能删除开头或是结尾的字符，不能删除中间部分的字符。默认是删除开头或结尾的空格。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;   Runoob    0090  &quot;</span>.strip()  <span class="comment"># 去除首尾空格  输出结果Runoob    0090</span></span><br></pre></td></tr></table></figure><blockquote><p>str.count(sub)方法返回子串sub在str中出现的次数。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;an apple a day&quot;</span>.count(<span class="string">&quot;a&quot;</span>)  <span class="comment"># 结果为 4</span></span><br></pre></td></tr></table></figure><blockquote><p>str.isalnum() 方法检测字符串是否由字母和数字组成。</p></blockquote><p><strong>注意：</strong>如果 string <strong>至少</strong>有一个字符并且所有字符都是字母或数字则返回 True,否则返回 False</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;abc&#x27;</span>.isalnum()   <span class="comment">#  结果为 True</span></span><br></pre></td></tr></table></figure><blockquote><p>str.replace(old, new)方法返回字符串str副本，所有old字符串都被替换为new字符串。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;python&quot;</span>.replace(<span class="string">&quot;n&quot;</span>,<span class="string">&quot;n123.io&quot;</span>)  <span class="comment"># 结果为 &quot;python123.io&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>str.center(width,[fillchar])根据宽度width显示居中字符串，fillchar可选。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;python&quot;</span>.center(<span class="number">20</span>,<span class="string">&quot;=&quot;</span>)  <span class="comment"># 结果为  &#x27;=======python=======&#x27;</span></span><br></pre></td></tr></table></figure><blockquote><p>str.join(iter)方法将在iter变量除最后元素外每个元素后增加一个str。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;,&quot;</span>.join(<span class="string">&quot;12345&quot;</span>)  <span class="comment"># 输出结果 &quot;1,2,3,4,5&quot; </span></span><br></pre></td></tr></table></figure><blockquote><p>rstrip() 方法将删除 string 字符串末尾的指定字符，默认为空白符，包括空格、换行符、回车符、制表符。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="string">&#x27;welcome,&#x27;</span>*<span class="number">3</span>).rstrip(<span class="string">&#x27;,&#x27;</span>)+<span class="string">&#x27;!&#x27;</span>   <span class="comment"># 输出结果  &#x27;welcome,welcome,welcome!&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="Python知识点（六）-面向对象程序设计"><a href="#Python知识点（六）-面向对象程序设计" class="headerlink" title="Python知识点（六）  面向对象程序设计"></a>Python知识点（六）  面向对象程序设计</h2><blockquote><p>私有成员，只有类对象自己能访问，子类对象不能直接访问这个成员，但在对象外部可以通过“对象名._类名__xxx”这样的特殊方式来访问。</p><p>注意：Python中不存在严格意义上的私有成员。</p></blockquote><h2 id="Python知识点（七）-异常处理"><a href="#Python知识点（七）-异常处理" class="headerlink" title="Python知识点（七）  异常处理"></a>Python知识点（七）  异常处理</h2><h3 id="try…except…finally结构"><a href="#try…except…finally结构" class="headerlink" title="try…except…finally结构"></a>try…except…finally结构</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    &lt;语句块<span class="number">1</span>&gt;          <span class="comment"># 需要检测异常的代码块</span></span><br><span class="line">    <span class="comment">#无异常，忽略except语句块</span></span><br><span class="line"><span class="keyword">except</span> &lt;异常名称<span class="number">1</span>&gt;：</span><br><span class="line">    &lt;语句块<span class="number">2</span>&gt;           <span class="comment"># 引发了异常名称1时执行语句块2</span></span><br><span class="line">[<span class="keyword">except</span> &lt;异常名称<span class="number">2</span>&gt;:  </span><br><span class="line">    &lt;语句块<span class="number">3</span>&gt;]          <span class="comment"># 引发了异常名称2时执行语句块3</span></span><br><span class="line">[<span class="keyword">else</span>:</span><br><span class="line">    &lt;语句块<span class="number">4</span>&gt;]         <span class="comment"># 无异常发生时执行的语句块</span></span><br><span class="line">[<span class="keyword">finally</span>:             <span class="comment">#关闭文件等后事处理，有无异常都执行</span></span><br><span class="line">    &lt;语句块<span class="number">5</span>&gt;]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="断言与上下文管理"><a href="#断言与上下文管理" class="headerlink" title="断言与上下文管理"></a>断言与上下文管理</h3><p>断言语句的语法是：assert expression[, reason] </p><p>当判断表达式expression为真时，什么都不做；如果表达式为假，则抛出异常。 </p><p>上下文管理语句：使用with自动关闭资源，可以在代码块执行完毕后还原进入该代码块时的现场。不论何种原因跳出with块，不论是否发生异常，总能保证文件被正确关闭，资源被正确释放。</p><h2 id="Python知识点（八）-注意点"><a href="#Python知识点（八）-注意点" class="headerlink" title="Python知识点（八）  注意点"></a>Python知识点（八）  注意点</h2><ol><li>python没有三元表达式，但有类似的语法表达方式：</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">result = x <span class="keyword">if</span> condition <span class="keyword">else</span> y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 还可以这样写</span></span><br><span class="line">result = (x, y)[condition]</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Python知识点（一）-运算符和表达式&quot;&gt;&lt;a href=&quot;#Python知识点（一）-运算符和表达式&quot; class=&quot;headerlink&quot; title=&quot;Python知识点（一）  运算符和表达式&quot;&gt;&lt;/a&gt;Python知识点（一）  运算符和表达式&lt;/h2</summary>
      
    
    
    
    <category term="Python基础" scheme="https://www.dp2002.top/categories/Python%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="计算机专业" scheme="https://www.dp2002.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A/"/>
    
    <category term="编程语言" scheme="https://www.dp2002.top/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="Python" scheme="https://www.dp2002.top/tags/Python/"/>
    
    <category term="知识点复习" scheme="https://www.dp2002.top/tags/%E7%9F%A5%E8%AF%86%E7%82%B9%E5%A4%8D%E4%B9%A0/"/>
    
    <category term="基础知识" scheme="https://www.dp2002.top/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>个人网站开发</title>
    <link href="https://www.dp2002.top/posts/1231/"/>
    <id>https://www.dp2002.top/posts/1231/</id>
    <published>2023-01-29T02:45:00.000Z</published>
    <updated>2023-02-02T13:09:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="网站开发基础"><a href="#网站开发基础" class="headerlink" title="网站开发基础"></a>网站开发基础</h2><h4 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h4><p>域名、服务器、搭建网站环境。</p><h4 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h4><p>【1】WordPress（开源建站系统）<br>可用于建造个人博客，企业官网，电商平台<br>特点：傻瓜式、多主题、插件丰富。<br><a href="https://cn.wordpress.org/">https://cn.wordpress.org/</a></p><p>【2】docsify（文档站点生成器）<br>特点：使用简单，可装插件、响应式。<br><a href="https://docsify.js.org/#/">https://docsify.js.org/#/</a></p><p>【3】dumi（文档站点生成器）<br>适合项目、产品的官网<br>特点：使用简单，专为组件开发场景而生<br><a href="https://d.umijs.org/">https://d.umijs.org/</a></p><p>【4】imgcook<br>根据设计稿一键智能生成代码<br>特点：傻瓜式操作，随意修改，AI生成代码<br><a href="https://www.imgcook.com/">https://www.imgcook.com/</a></p><p>【5】ant design landing<br>网站首页生成器<br>特点：模板丰富，可视化编辑网页元素，可一键上传网站，不需要购买服务器、域名等。<br><a href="https://ant-design-landing.gitee.io/index-cn">https://ant-design-landing.gitee.io/index-cn</a></p><p>【6】TX兔小巢<br>产品反馈平台<br>特点：免费，一键生成网站反馈社区<br><a href="https://txc.qq.com/">https://txc.qq.com/</a></p><p>【7】百度统计<br>网站数据统计<br>特点：多场景统计分析，简单易用<br><a href="https://tongji.baidu.com/web/welcome/login">https://tongji.baidu.com/web/welcome/login</a></p><p>【8】Discuz Q<br>PC端开源社区软件<br>特点：开源，功能丰富<br><a href="https://discuz.chat/?categoryId=all&sequence=0">https://discuz.chat/?categoryId=all&amp;sequence=0</a></p><p>【9】tailwindcss<br>UI框架，提供现成具体好看的css样式，帮助我们快速构建现代化网站<br><a href="https://www.tailwindcss.cn/">https://www.tailwindcss.cn/</a></p><h2 id="班级网站需求分析"><a href="#班级网站需求分析" class="headerlink" title="班级网站需求分析"></a>班级网站需求分析</h2><p>根据调查，必须让同学们有收获，或者说有正反馈，这是能让同学们关注并使用网站的第一步。</p><ol><li>班级简介</li><li>班级通知、布置作业、课程表</li><li>留言板（提建议）</li><li>班级事迹、文体活动</li><li>思想建设</li><li>新鲜事</li><li>友情链接（学校网站、好用的工具）</li><li>学校风光</li><li>设置一个点歌的小插件，最好能听一些付费的歌曲。</li><li>百度搜索功能</li><li>时间显示功能</li><li>计算综测分</li><li>点名统计</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;网站开发基础&quot;&gt;&lt;a href=&quot;#网站开发基础&quot; class=&quot;headerlink&quot; title=&quot;网站开发基础&quot;&gt;&lt;/a&gt;网站开发基础&lt;/h2&gt;&lt;h4 id=&quot;基础知识&quot;&gt;&lt;a href=&quot;#基础知识&quot; class=&quot;headerlink&quot; title=&quot;基</summary>
      
    
    
    
    <category term="网站开发" scheme="https://www.dp2002.top/categories/%E7%BD%91%E7%AB%99%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="计算机专业" scheme="https://www.dp2002.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A/"/>
    
    <category term="网站必备" scheme="https://www.dp2002.top/tags/%E7%BD%91%E7%AB%99%E5%BF%85%E5%A4%87/"/>
    
    <category term="搭建个人网站" scheme="https://www.dp2002.top/tags/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99/"/>
    
  </entry>
  
  <entry>
    <title>找工作，投简历</title>
    <link href="https://www.dp2002.top/posts/1342/"/>
    <id>https://www.dp2002.top/posts/1342/</id>
    <published>2023-01-29T02:45:00.000Z</published>
    <updated>2023-02-02T13:09:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="投简历"><a href="#投简历" class="headerlink" title="投简历"></a>投简历</h1><h2 id="海投"><a href="#海投" class="headerlink" title="海投"></a>海投</h2><h2 id="公司是否靠谱"><a href="#公司是否靠谱" class="headerlink" title="公司是否靠谱"></a>公司是否靠谱</h2><ol><li>百度百科</li><li>爱企查</li><li>招聘软件上面看面试评价</li><li>自己来感受（第六感🤪）</li></ol><h1 id="面试技巧"><a href="#面试技巧" class="headerlink" title="面试技巧"></a>面试技巧</h1><h2 id="自我推销"><a href="#自我推销" class="headerlink" title="自我推销"></a>自我推销</h2><p>你的薪资期望有点高，可以商量吗？</p><p>最好不要说可以或不可以。首先，可以介绍自己是综合多方面的考量来到贵公司的，贵公司很好（巴拉巴拉），我很中意，薪资方面可以适当减低的。</p><h2 id="真诚和礼貌是必杀技"><a href="#真诚和礼貌是必杀技" class="headerlink" title="真诚和礼貌是必杀技"></a>真诚和礼貌是必杀技</h2><p>不要说什么丧气话，也不要说以后要跳槽或者考公考编，这样会让HR认为培养你不是为了公司的。</p><h1 id="当心坠坑"><a href="#当心坠坑" class="headerlink" title="当心坠坑"></a>当心坠坑</h1><ol><li>薪资诱人，接受零基础</li><li>面试邀约公司与实际地点公司不一样，介绍也不实际</li><li>还没工作，就先要给钱（培训费、违约金等等）</li><li>抵扣学位证或身份证进行贷款</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;投简历&quot;&gt;&lt;a href=&quot;#投简历&quot; class=&quot;headerlink&quot; title=&quot;投简历&quot;&gt;&lt;/a&gt;投简历&lt;/h1&gt;&lt;h2 id=&quot;海投&quot;&gt;&lt;a href=&quot;#海投&quot; class=&quot;headerlink&quot; title=&quot;海投&quot;&gt;&lt;/a&gt;海投&lt;/h2&gt;&lt;h</summary>
      
    
    
    
    <category term="实习" scheme="https://www.dp2002.top/categories/%E5%AE%9E%E4%B9%A0/"/>
    
    
    <category term="实习工作" scheme="https://www.dp2002.top/tags/%E5%AE%9E%E4%B9%A0%E5%B7%A5%E4%BD%9C/"/>
    
    <category term="随笔小记" scheme="https://www.dp2002.top/tags/%E9%9A%8F%E7%AC%94%E5%B0%8F%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>系统设计入门</title>
    <link href="https://www.dp2002.top/posts/0000/"/>
    <id>https://www.dp2002.top/posts/0000/</id>
    <published>2023-01-29T02:45:00.000Z</published>
    <updated>2023-02-02T13:09:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h2><h3 id="Load-Balancing-负载均衡"><a href="#Load-Balancing-负载均衡" class="headerlink" title="Load Balancing  负载均衡"></a>Load Balancing  负载均衡</h3><p>用来保护Web server，把请求打到应该打到的服务上（现在大厂，网关+RPC）</p><p>当用户登录某一网页时，浏览器通过DNS服务器域名解析后拿到的IP可能是某个Load Balancer的IP地址， 而不是web server的IP地址。用户发送的请求通过Load Balancer 均匀地分发给web server进行处理。</p><p>常见算法：比如round robin（轮询调度）, least connection（最小连接数法）, hashing（哈希散列）等。。。。 </p><p>High Scalability  （高扩展） ：扩容，Load Balancer下添加更多的web server，来服务更多的用户。</p><p>High Availability （高可用）：Load Balancer持续监听每台web server的状态是否OK，确保将用户请求发给状态OK的web server，挂机的web server就拜拜了，保证服务不中断。</p><p>有小伙伴还会问那Load Balancer也挂掉了呢？</p><p>那Load Balancer肯定也有备份的啦，一个 Load balancer 挂掉，或者是 BGP 发布取消，备份的 Load balancer可以马上接管流量，继续进行响应。</p><p><img src="https://img1.imgtp.com/2023/02/03/5mJLtkQD.png"></p><h3 id="Database-Design-数据库设计"><a href="#Database-Design-数据库设计" class="headerlink" title="Database Design  数据库设计"></a>Database Design  数据库设计</h3><p>一个是设计data model数据模型</p><p>另一个是数据库的选型</p><p>ps：两者互相关联，因为数据库选型的一个重要参数就是数据模型</p><p>eg :  YouTube de metadata  –&gt; mysql、pg</p><p>电商3网站的产品目录，什么鬼东西都有 –&gt; NoSQL (Cassandra. HBase. MongoDB</p><p>等)</p><p>关系型数据库误区，说关系型数据库不能Scalability，大规模化存储数据，听着有点怪怪的，我们学习数据库都有接触到分库分表、docker &amp;&amp; K8s承载数据库集群，现在大厂的还有云数据库等等。。。</p><p>up提到YouTube的分布式MySQL方案（Vitess）倒是不错，可以看看。</p><p>关系型数据库都需要 data partitioning（数据分区、分片） 的方案，都需要选择 partitioning key（设计构造好分区键值）</p><h3 id="Caching-存储中间件（Memcache、Redis）"><a href="#Caching-存储中间件（Memcache、Redis）" class="headerlink" title="Caching 存储中间件（Memcache、Redis）"></a>Caching 存储中间件（Memcache、Redis）</h3><p>memcache是一套分布式的高速缓存系统</p><h3 id="CDN（Content-Delivery-Network内容分发网络）"><a href="#CDN（Content-Delivery-Network内容分发网络）" class="headerlink" title="CDN（Content Delivery Network内容分发网络）"></a>CDN（Content Delivery Network内容分发网络）</h3><p><img src="https://img1.imgtp.com/2023/02/03/4VQPAi5E.png" alt="image-20230118184031266"></p><h3 id="Asynchronous-processing-异步处理"><a href="#Asynchronous-processing-异步处理" class="headerlink" title="Asynchronous processing 异步处理"></a>Asynchronous processing 异步处理</h3><p>先来说说同步处理 (synchronous processing)，如果一个任务是同步处理，那调用者必须等到任务结束，才能继续后面的工作。比如，</p><p>如果一个任务是异步执行的，那么任务的调用者，不用等到任务结束。</p><p>常规解决方案：解耦（MQ）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;系统设计&quot;&gt;&lt;a href=&quot;#系统设计&quot; class=&quot;headerlink&quot; title=&quot;系统设计&quot;&gt;&lt;/a&gt;系统设计&lt;/h2&gt;&lt;h3 id=&quot;Load-Balancing-负载均衡&quot;&gt;&lt;a href=&quot;#Load-Balancing-负载均衡&quot; class</summary>
      
    
    
    
    <category term="系统开发" scheme="https://www.dp2002.top/categories/%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="计算机专业" scheme="https://www.dp2002.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A/"/>
    
    <category term="系统设计优化" scheme="https://www.dp2002.top/tags/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络简明教程</title>
    <link href="https://www.dp2002.top/posts/2892/"/>
    <id>https://www.dp2002.top/posts/2892/</id>
    <published>2023-01-29T02:45:00.000Z</published>
    <updated>2023-02-15T02:45:00.000Z</updated>
    
    <content type="html"><![CDATA[<!-- ---title: 文章标题date: 创建日期updated: 更新日期cover: 文章封面description: 文章描述swiper_index: 1 #置顶轮播图顺序，非负整数，数字越大越靠前sticky: 文章置顶comment: 评论top_image: false--- --><h2 id="第-一-章"><a href="#第-一-章" class="headerlink" title="第 一 章"></a>第 一 章</h2><h3 id="1-互联网的概述"><a href="#1-互联网的概述" class="headerlink" title="1. 互联网的概述"></a>1. 互联网的概述</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>计算机网络由若干个<u>节点</u>和连接这些节点的<u>链路</u>组成。</p><h4 id="基础结构发展的三个阶段"><a href="#基础结构发展的三个阶段" class="headerlink" title="基础结构发展的三个阶段"></a>基础结构发展的三个阶段</h4><p>   ① 美国的ARPANET → 形成Internet<br>   ② 建成了三级结构的互联网<br>   ③ 形成了全球范围的多层次ISP结构的互联网</p><h3 id="2-互联网的组成"><a href="#2-互联网的组成" class="headerlink" title="2. 互联网的组成"></a>2. 互联网的组成</h3><ul><li>边缘部分： 主机，其作用是进行信息处理。</li></ul><h4 id="计算机通信是计算机中的进程之间的通信"><a href="#计算机通信是计算机中的进程之间的通信" class="headerlink" title="计算机通信是计算机中的进程之间的通信"></a>计算机通信是计算机中的进程之间的通信</h4><h4 id="计算机通信方式：客户-服务器方式（C-x2F-S）和对等连接方式（P2P方式）"><a href="#计算机通信方式：客户-服务器方式（C-x2F-S）和对等连接方式（P2P方式）" class="headerlink" title="计算机通信方式：客户-服务器方式（C&#x2F;S）和对等连接方式（P2P方式）"></a>计算机通信方式：客户-服务器方式（C&#x2F;S）和对等连接方式（P2P方式）</h4><ul><li>核心部分： 路由器，其作用是按存储转发方式进行分组交换。</li></ul><h4 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h4><h4 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h4><h4 id="报文交换"><a href="#报文交换" class="headerlink" title="报文交换"></a>报文交换</h4><h3 id="3-计算机网络的类别"><a href="#3-计算机网络的类别" class="headerlink" title="3. 计算机网络的类别"></a>3. 计算机网络的类别</h3><ul><li>按分布范围分类：广域网（WAN）、城域网（MAN）、局域网（LAN）、个人区域网（PAN）</li><li>按拓扑结构分类：星形网络、总线型网络、环形网络、网状形网络</li><li>按传输技术分类：广播式网络、点对点网络</li><li>按使用者分类：公用网、专用网</li><li>按数据交换技术分类：电路交换网络、报文交换网络、分组交换网络</li></ul><h3 id="4-计算机网络的性能指标"><a href="#4-计算机网络的性能指标" class="headerlink" title="4. 计算机网络的性能指标"></a>4. 计算机网络的性能指标</h3><p>（1）速率</p><p>（2）带宽</p><p>（3）吞吐量</p><p>（4）时延</p><ul><li>发送时延</li><li>传播时延<br>   * 处理时延<br>   * 排队时延</li></ul><p>（5）利用率</p><h3 id="5-计算机网络体系结构"><a href="#5-计算机网络体系结构" class="headerlink" title="5. 计算机网络体系结构"></a>5. 计算机网络体系结构</h3><p>（1）概念</p><p>​计算机的各层及其协议的集合，称为网络的体系结构</p><p>（2）协议三要素：</p><p>​语法</p><p>​语义</p><p>​同步</p><hr><h2 id="第-二-章-物理层（P53）"><a href="#第-二-章-物理层（P53）" class="headerlink" title="第 二 章  物理层（P53）"></a>第 二 章  物理层（P53）</h2><p>在物理层上所传数据的单位为比特</p><h3 id="1-物理层要解决的主要问题："><a href="#1-物理层要解决的主要问题：" class="headerlink" title="1. 物理层要解决的主要问题："></a>1. 物理层要解决的主要问题：</h3><p>要尽可能地屏蔽掉不同传输媒体和通信手段的差异，使数据链路层感觉不到这些差异，只考虑完成本层的协议和服务。</p><h4 id="2-物理层的主要特点："><a href="#2-物理层的主要特点：" class="headerlink" title="2. 物理层的主要特点："></a>2. 物理层的主要特点：</h4><p>（1）由于在OSI之前，许多物理规程或协议已经制定出来了，而且在数据通信领域中，这些物理规程已被许多商品化的设备所采用，加之，物理层协议涉及的范围广泛，所以至今没有按OSI的抽象模型制定一套新的物理层协议，而是沿用已存在的物理规程，将物理层确定为描述与传输媒体接口的机械，电气，功能和规程特性。<br>（2）由于物理连接的方式很多，传输媒体的种类也很多，因此，具体的物理协议相当复杂。</p><h4 id="3-试解释以下名词：数据，信号，模拟数据，模拟信号，基带信号，带通信号，数字数据，数字信号，码元，单工通信，半双工通信，全双工通信，串行传输，并行传输。"><a href="#3-试解释以下名词：数据，信号，模拟数据，模拟信号，基带信号，带通信号，数字数据，数字信号，码元，单工通信，半双工通信，全双工通信，串行传输，并行传输。" class="headerlink" title="3. 试解释以下名词：数据，信号，模拟数据，模拟信号，基带信号，带通信号，数字数据，数字信号，码元，单工通信，半双工通信，全双工通信，串行传输，并行传输。"></a>3. <strong>试解释以下名词：数据，信号，模拟数据，模拟信号，基带信号，带通信号，数字数据，数字信号，码元，单工通信，半双工通信，全双工通信，串行传输，并行传输。</strong></h4><ul><li><p>数据：是运送信息的实体。</p></li><li><p>信号：则是数据的电气的或电磁的表现。</p></li><li><p>模拟数据：运送信息的模拟信号。</p></li><li><p>模拟信号：代表消息的参数的取值是连续的。 </p></li><li><p>基带信号：来自信源的信号。像计算机输出的代表各种文字或图像文件的数据信号都属于基带信号。</p></li><li><p>带通信号：把基带信号经过载波调制后，把信号的频率范围搬移到较高的频段以便在信道中传输。</p></li><li><p>数字数据：取值为不连续数值的数据。</p></li><li><p>数字信号：代表消息的参数的取值是离散的。 </p></li><li><p>码元：在使用时间域（或简称为时域）的波形表示数字信号时，代表不同离散数值的基本波形。</p></li><li><p>单工通信：即只有一个方向的通信而没有反方向的交互。</p></li><li><p>半双工通信：即通信和双方都可以发送信息，但不能双方同时发送（当然也不能同时接收）。这种通信方式是一方发送</p><p>另一方接收，过一段时间再反过来。</p></li><li><p>全双工通信：即通信的双方可以同时发送和接收信息。</p></li><li><p>串行传输：使用一根数据线传输数据，一次传输1个比特，多个比特需要一个接一个依次传输。</p></li><li><p>并行传输：使用多根数据线一次传输多个比特。</p></li></ul><h4 id="4-物理层的接口有哪几个方面的特性？各包含些什么内容？"><a href="#4-物理层的接口有哪几个方面的特性？各包含些什么内容？" class="headerlink" title="4. 物理层的接口有哪几个方面的特性？各包含些什么内容？"></a>4. <strong>物理层的接口有哪几个方面的特性？各包含些什么内容？</strong></h4><ul><li>机械特性</li><li>电气特性</li><li>功能特性</li><li>过程特性</li></ul><h4 id="5-常用的传输媒体有哪几种？各有何特点？"><a href="#5-常用的传输媒体有哪几种？各有何特点？" class="headerlink" title="5. 常用的传输媒体有哪几种？各有何特点？"></a>5. <strong>常用的传输媒体有哪几种？各有何特点？</strong></h4><ul><li><p>双绞线<br>最常用的传输媒体。双绞线分屏蔽双绞线和无屏蔽双绞线。可以传输模拟信号，也可以传输数字信号，其通信距离一般为<strong>几到十几公里</strong>。一般用作电话线传输声音信号。双绞线容易受到外部高频电磁波的干扰，误码率高。</p></li><li><p>同轴电缆</p><p>同轴电缆具有很好的抗干扰特性，被广泛用于传输较高速率的数据。同轴电缆的带宽取决于电缆的质量。</p><p>50 Ω 同轴电缆 —— LAN &#x2F; 数字传输常用<br>75 Ω 同轴电缆 —— 有线电视 &#x2F; 模拟传输常用</p></li><li><p>光导纤维<br>光导纤维以光纤维载体，利用光的全反向原理传播光信号。其优点是直径小、质量轻：传播频带款、通信容量大：抗雷电和电磁干扰性能好，五串音干扰、保密性好、误码率低。</p><blockquote><p>光纤优点</p><p>(1) 通信容量非常大。<br>(2) 传输损耗小，中继距离长。<br>(2) 抗雷电和电磁干扰性能好。<br>(3) 无串音干扰，保密性好。<br>(4) 体积小，重量轻。</p></blockquote></li><li><p>无线电微波通信<br>无线电微波通信分为<strong>地面微波接力通信</strong>和<strong>卫星通信</strong>。其主要优点是频率高、频带范围宽、通信信道的容量大；信号所受工业干扰较小、传播质量高、通信比较稳定；不受地理环境的影响，建设投资少、见效快。缺点是地面微波接力通信在空间是直线传播，传输距离受到限制，一般只有50km，隐蔽性和保密性较差；卫星通信虽然通信距离远且通信费用与通信距离无关，但传播时延较大。</p></li></ul><h4 id="6-为什么要使用信道复用技术？常用的信道复用技术有哪些？"><a href="#6-为什么要使用信道复用技术？常用的信道复用技术有哪些？" class="headerlink" title="6. 为什么要使用信道复用技术？常用的信道复用技术有哪些？"></a>6. <strong>为什么要使用信道复用技术？常用的信道复用技术有哪些？</strong></h4><p>为了通过共享信道，最大限度提高信道利用率。频分复用、时分复用、码分复用、波分复用。</p><hr><h2 id="第-三-章-数据链路层（P74）"><a href="#第-三-章-数据链路层（P74）" class="headerlink" title="第 三 章 数据链路层（P74）"></a>第 三 章 数据链路层（P74）</h2><p>数据链路层的三个基本问题：封装成帧、透明传输、差错检测，单位为帧</p><h4 id="1-数据链路层的三个基本问题-帧定界、透明传输和差错检测-为什么都必须加以解决？"><a href="#1-数据链路层的三个基本问题-帧定界、透明传输和差错检测-为什么都必须加以解决？" class="headerlink" title="1. 数据链路层的三个基本问题(帧定界、透明传输和差错检测)为什么都必须加以解决？"></a>1. <strong>数据链路层的三个基本问题(帧定界、透明传输和差错检测)为什么都必须加以解决？</strong></h4><p>封装成帧： 在数据前后加上帧头和帧尾后，接收端接的数据链路层接收到物理层传来的比特流才能根据帧头帧尾识别一个帧。<br>透明传输： 防止数据中出现与帧定界符相同的比特组合导致出现帧定界错误，而在发送端数据中的帧定界符或前加入转义字符，在接收端把接收到数据中多余的转义字符去掉。这样就可以使数据无差错地通过数据链路层，即实现透明传输。<br>差错检验： 为了节约网络资源，使错误数据到达节点或主机的数据链路层就能被尽快检测到，而不是到达主机后，主机的高层软件进行检测。这样就能使错误数据尽少的占用通信资源。</p><h4 id="2-如果在数据链路层不进行封装成帧，会发生什么问题？"><a href="#2-如果在数据链路层不进行封装成帧，会发生什么问题？" class="headerlink" title="2.  如果在数据链路层不进行封装成帧，会发生什么问题？"></a>2.  如果在数据链路层不进行封装成帧，会发生什么问题？</h4><p>如果在数据链路层不进行封装成帧，那么数据链路层在收到一些数据时，就无法知道对方传送的数据中哪些是数据，哪些是控制信息，甚至数据中有没有差错也不清楚（因为无法进行差错检测)。</p><p>数据链路层也无法知道数据传送结束了没有，因此不知道应当在什么时候把收到的数据交给上一层。</p><h4 id="3-PPP协议使用同步传输技术传送比特串0110111111111100。试问经过零比特填充后变成怎样的比特串？若接收端收到的PPP帧的数据部分是0001110111110111110110，问删除发送端加入的零比特后变成怎样的比特串？"><a href="#3-PPP协议使用同步传输技术传送比特串0110111111111100。试问经过零比特填充后变成怎样的比特串？若接收端收到的PPP帧的数据部分是0001110111110111110110，问删除发送端加入的零比特后变成怎样的比特串？" class="headerlink" title="3.  PPP协议使用同步传输技术传送比特串0110111111111100。试问经过零比特填充后变成怎样的比特串？若接收端收到的PPP帧的数据部分是0001110111110111110110，问删除发送端加入的零比特后变成怎样的比特串？"></a>3.  PPP协议使用同步传输技术传送比特串0110111111111100。试问经过零比特填充后变成怎样的比特串？若接收端收到的PPP帧的数据部分是0001110111110111110110，问删除发送端加入的零比特后变成怎样的比特串？</h4><p>填充后：011011111011111000<br>填充前：00011101111111111110</p><h4 id="4-以太网使用的CSMA-x2F-CD协议是以争用方式接入到共享信道。这与传统的时分复用TDM相比优缺点如何？"><a href="#4-以太网使用的CSMA-x2F-CD协议是以争用方式接入到共享信道。这与传统的时分复用TDM相比优缺点如何？" class="headerlink" title="4.  以太网使用的CSMA&#x2F;CD协议是以争用方式接入到共享信道。这与传统的时分复用TDM相比优缺点如何？"></a>4.  以太网使用的CSMA&#x2F;CD协议是以争用方式接入到共享信道。这与传统的时分复用TDM相比优缺点如何？</h4><p>在网络负荷较轻时，CSMA&#x2F;CD协议下任何站都可以发送，信道利用率高。而TDM下每个站都分配固定时隙，会有大量比例的时隙浪费，信道利用率就比较低。</p><p>网络负荷较重时，CSMA&#x2F;CD协议下容易引起碰撞，经常发生重传，而TDM下每个站均匀分配时隙，不会发生碰撞。</p><h4 id="5-有10个站连接到以太网上。试计算一下三种情况下每一个站所能得到的带宽。"><a href="#5-有10个站连接到以太网上。试计算一下三种情况下每一个站所能得到的带宽。" class="headerlink" title="5.  有10个站连接到以太网上。试计算一下三种情况下每一个站所能得到的带宽。"></a>5.  有10个站连接到以太网上。试计算一下三种情况下每一个站所能得到的带宽。</h4><p>（1）10个站都连接到一个10Mb&#x2F;s以太网集线器；</p><p>假定以太网的利用率基本上达到100%，那么10个站共享10Mbit&#x2F;s,即平均每一个站可得到1Mbit&#x2F;s的带宽。</p><p>（2）10个站都连接到一个100Mb&#x2F;s以太网集线器；</p><p>假定以太网的利用率基本上达到100%，那么10个站共享100Mbit&#x2F;s,即平均每一个站可得到10Mbit&#x2F;s的带宽。</p><p>（3）10个站都连接到一个10Mb&#x2F;s以太网交换机。</p><p>每一个站独占交换机的一个接口的带宽10Mbit&#x2F;s。这里我们假定这个交换机的总带宽不小于100Mbit&#x2F;s。</p><h4 id="6-以太网交换机的工作原理和特点是什么？以太网交换机和转发器有何异同？"><a href="#6-以太网交换机的工作原理和特点是什么？以太网交换机和转发器有何异同？" class="headerlink" title="6.  以太网交换机的工作原理和特点是什么？以太网交换机和转发器有何异同？"></a>6.  以太网交换机的工作原理和特点是什么？以太网交换机和转发器有何异同？</h4><h2 id="第-四-章-网络层（P110）"><a href="#第-四-章-网络层（P110）" class="headerlink" title="第 四 章 网络层（P110）"></a>第 四 章 网络层（P110）</h2><p>单位为分组</p><h2 id="第-五-章-运输层（P136）"><a href="#第-五-章-运输层（P136）" class="headerlink" title="第 五 章 运输层（P136）"></a>第 五 章 运输层（P136）</h2><p>可靠传输、流量控制、拥塞控制，单位为报文段</p><h3 id="一、运输层的端口号和套接字的意义"><a href="#一、运输层的端口号和套接字的意义" class="headerlink" title="一、运输层的端口号和套接字的意义"></a>一、运输层的端口号和套接字的意义</h3><p>端口是应用层的各种协议进程与运输实体进行层间交互的地点。</p><p>TCP用主机的IP地址加上主机上的端口号作为TCP连接的端点，叫作套接字（socket）  （IP地址：端口号）来表示。</p><p><img src="https://img1.imgtp.com/2023/02/03/pJQoxtuR.png"></p><p><img src="https://img1.imgtp.com/2023/02/03/dljeoSwk.png" alt="image-20230114230046659"></p><p><img src="https://img1.imgtp.com/2023/02/03/VQNeFSFY.png" alt="image-20230114230105768"></p><h3 id="二、UDP和TCP的对比"><a href="#二、UDP和TCP的对比" class="headerlink" title="二、UDP和TCP的对比"></a>二、UDP和TCP的对比</h3><p><img src="https://img1.imgtp.com/2023/02/03/v74tbIMP.png" alt="image-20230114230126356"></p><h3 id="三、流量控制"><a href="#三、流量控制" class="headerlink" title="三、流量控制"></a>三、流量控制</h3><p><img src="https://img1.imgtp.com/2023/02/03/38wTHdm8.png" alt="image-20230114230138781"></p><p><img src="https://img1.imgtp.com/2023/02/03/sK0UNqnX.png" alt="image-20230114230150946"></p><p><img src="https://img1.imgtp.com/2023/02/03/PmdbTose.png" alt="image-20230114230204434"></p><h3 id="四、可靠传输"><a href="#四、可靠传输" class="headerlink" title="四、可靠传输"></a>四、可靠传输</h3><p><img src="https://img1.imgtp.com/2023/02/03/0iU9801D.png" alt="image-20230115145333407"></p><h5 id="停止-等待协议"><a href="#停止-等待协议" class="headerlink" title="停止-等待协议"></a>停止-等待协议</h5><p><img src="https://img1.imgtp.com/2023/02/03/YDB6V3Or.png" alt="image-20230115150939273"></p><p><img src="https://img1.imgtp.com/2023/02/03/EIoKtTVR.png" alt="image-20230115151729196"></p><p><img src="https://img1.imgtp.com/2023/02/03/5Ht1Bmp1.png" alt="image-20230115151757295"></p><h5 id="后退N帧协议"><a href="#后退N帧协议" class="headerlink" title="后退N帧协议"></a>后退N帧协议</h5><p><img src="https://img1.imgtp.com/2023/02/03/vJkJUSyP.png" alt="image-20230115163558383"></p><p><img src="https://img1.imgtp.com/2023/02/03/8wbCLikN.png" alt="image-20230115162943337"></p><p><img src="https://img1.imgtp.com/2023/02/03/m7AhhxWu.png" alt="image-20230115163450863"></p><h5 id="选择重传协议"><a href="#选择重传协议" class="headerlink" title="选择重传协议"></a>选择重传协议</h5><p><img src="https://img1.imgtp.com/2023/02/03/EdtxAJ5d.png" alt="image-20230115171035189"></p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p><img src="https://img1.imgtp.com/2023/02/03/LK7vQyXc.png" alt="image-20230115170847904"></p><p>确认号指的是接收方想要接收的报文段的序号。</p><h3 id="五、拥塞控制"><a href="#五、拥塞控制" class="headerlink" title="五、拥塞控制"></a>五、拥塞控制</h3><p><img src="https://img1.imgtp.com/2023/02/03/p1kwJO09.png" alt="image-20230119103310461"></p><p><img src="https://img1.imgtp.com/2023/02/03/PK2yJQv4.png" alt="image-20230119112042661"></p><p><img src="https://img1.imgtp.com/2023/02/03/FqeZ41gs.png" alt="image-20230119112131896"></p><h3 id="六、TCP的运输连接管理-P134"><a href="#六、TCP的运输连接管理-P134" class="headerlink" title="六、TCP的运输连接管理(P134)"></a>六、TCP的运输连接管理(P134)</h3><blockquote><p>TCP运输连接的三个阶段：</p></blockquote><p><img src="https://img1.imgtp.com/2023/02/03/7vQ7l7jY.png" alt="image-20230119091909624"></p><p><img src="https://img1.imgtp.com/2023/02/03/xkeL3f5p.png" alt="image-20230119092914852"></p><h3 id="七、TCP-的三次握手，四次挥手机制"><a href="#七、TCP-的三次握手，四次挥手机制" class="headerlink" title="七、TCP 的三次握手，四次挥手机制"></a>七、TCP 的三次握手，四次挥手机制</h3><blockquote><p>TCP客户端进程主动打开或关闭，TCP服务端进程被动打开（监听）或关闭。</p></blockquote><p><img src="https://img1.imgtp.com/2023/02/03/O2RReCKM.png" alt="image-20230119092647193"></p><blockquote><p>如上图，二次握手的话，在结尾时客户没有对TCP连接请求进行确认，没有任何回应，导致服务器资源浪费（白白等待着客户发送数据）。</p></blockquote><p><img src="https://img1.imgtp.com/2023/02/03/aKSjakhh.png" alt="image-20230119143818139"></p><blockquote><p>再如上图，三次握手，如果使用三报文握手，那么B在收到A发送的陈旧的SYN报文段后，就向A发送SYN报文段，选择自己的序号seq&#x3D;y，并确认收到A的SYN报文段，其确认号ack&#x3D;x+1。当A收到B的SYN报文段时，从确认号就可得知不应当理睬这个SYN报文段（因为A现在并没有发送sq&#x3D;x的SYN报文段)。这时，A发送复位报文段。在这个报文段中，RST&#x3D;1，ACK&#x3D;1，其确认号ack&#x3D;y+1。我们注意到，虽然A拒绝了TCP连接的建立（发送了复位报文段），但对B发送的SYN报文段还是确认收到了。</p><p><strong>B收到A的RST报文段后</strong>，就知道不能建立TCP连接，不会等待A发送数据了，就不会白白等待了。</p></blockquote><p><img src="https://img1.imgtp.com/2023/02/03/uboaX2Aw.png" alt="image-20230119093607814"></p><p><img src="https://img1.imgtp.com/2023/02/03/S10IhjSG.png" alt="image-20230119093654948"></p><p><img src="https://img1.imgtp.com/2023/02/03/B8dOdRBf.png" alt="image-20230119093803247"></p><h2 id="第-六-章-应用层"><a href="#第-六-章-应用层" class="headerlink" title="第 六 章 应用层"></a>第 六 章 应用层</h2><p><img src="https://img1.imgtp.com/2023/02/03/rIrhyVnP.png" alt="image-20230119102635861"></p><h2 id="参考视频"><a href="#参考视频" class="headerlink" title="参考视频"></a>参考视频</h2><div class="tabs" id="参考资料"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#参考资料-1">参考视频</button></li><li class="tab"><button type="button" data-href="#参考资料-2">参考资料</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="参考资料-1"><div align=center class="aspect-ratio">    <iframe src="//player.bilibili.com/player.html?bvid=BV1Ut411d7RE&page=1&high_quality=1&danmaku=0"      scrolling="no"       border="0"       frameborder="no"       framespacing="0"       high_quality=1      danmaku=1       allowfullscreen="true"      high_quality=1>     </iframe></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="参考资料-2"><p><strong>《计算机网络简明教程》（第四版） 编著谢希仁，北京：电子工业出版社</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>]]></content>
    
    
    <summary type="html">✍️这是计算机网站期末复习的文章</summary>
    
    
    
    <category term="计算机基础" scheme="https://www.dp2002.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="计算机专业" scheme="https://www.dp2002.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A/"/>
    
    <category term="知识点复习" scheme="https://www.dp2002.top/tags/%E7%9F%A5%E8%AF%86%E7%82%B9%E5%A4%8D%E4%B9%A0/"/>
    
    <category term="基础知识" scheme="https://www.dp2002.top/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    <category term="计算机网络" scheme="https://www.dp2002.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="TCP/IP" scheme="https://www.dp2002.top/tags/TCP-IP/"/>
    
    <category term="HTTP" scheme="https://www.dp2002.top/tags/HTTP/"/>
    
  </entry>
  
</feed>
