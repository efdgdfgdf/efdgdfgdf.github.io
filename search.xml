<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Python期末复习</title>
      <link href="/2023/01/29/Python%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"/>
      <url>/2023/01/29/Python%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="Python知识点（一）-字符串处理方法"><a href="#Python知识点（一）-字符串处理方法" class="headerlink" title="Python知识点（一）  字符串处理方法"></a>Python知识点（一）  字符串处理方法</h2><blockquote><p>str.lower() 或 str.upper()方法返回字符串的副本，全部字符小写&#x2F;大写。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;AbCdEfGh&quot;</span>.lower() <span class="comment"># 结果为 &quot;abcdefgh&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>str.split(sep&#x3D;None)方法返回一个列表，由str根据sep被分隔的字段组成。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;A,B,C&quot;</span>.split(<span class="string">&quot;,&quot;</span>)  <span class="comment"># 结果为 [&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;]</span></span><br></pre></td></tr></table></figure><blockquote><p>str.strip() 方法用于移除字符串头尾指定的字符（默认为空格或换行符）或字符序列。</p></blockquote><p><strong>注意：</strong>该方法只能删除开头或是结尾的字符，不能删除中间部分的字符。默认是删除开头或结尾的空格。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;   Runoob    0090  &quot;</span>.strip()  <span class="comment"># 去除首尾空格  输出结果Runoob    0090</span></span><br></pre></td></tr></table></figure><blockquote><p>str.count(sub)方法返回子串sub在str中出现的次数。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;an apple a day&quot;</span>.count(<span class="string">&quot;a&quot;</span>)  <span class="comment"># 结果为 4</span></span><br></pre></td></tr></table></figure><blockquote><p>str.isalnum() 方法检测字符串是否由字母和数字组成。</p></blockquote><p><strong>注意：</strong>如果 string <strong>至少</strong>有一个字符并且所有字符都是字母或数字则返回 True,否则返回 False</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;abc&#x27;</span>.isalnum()   <span class="comment">#  结果为 True</span></span><br></pre></td></tr></table></figure><blockquote><p>str.replace(old, new)方法返回字符串str副本，所有old字符串都被替换为new字符串。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;python&quot;</span>.replace(<span class="string">&quot;n&quot;</span>,<span class="string">&quot;n123.io&quot;</span>)  <span class="comment"># 结果为 &quot;python123.io&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>str.center(width,[fillchar])根据宽度width显示居中字符串，fillchar可选。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;python&quot;</span>.center(<span class="number">20</span>,<span class="string">&quot;=&quot;</span>)  <span class="comment"># 结果为  &#x27;=======python=======&#x27;</span></span><br></pre></td></tr></table></figure><blockquote><p>str.join(iter)方法将在iter变量除最后元素外每个元素后增加一个str。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;,&quot;</span>.join(<span class="string">&quot;12345&quot;</span>)  <span class="comment"># 输出结果 &quot;1,2,3,4,5&quot; </span></span><br></pre></td></tr></table></figure><blockquote><p>rstrip() 方法将删除 string 字符串末尾的指定字符，默认为空白符，包括空格、换行符、回车符、制表符。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="string">&#x27;welcome,&#x27;</span>*<span class="number">3</span>).rstrip(<span class="string">&#x27;,&#x27;</span>)+<span class="string">&#x27;!&#x27;</span>   <span class="comment"># 输出结果  &#x27;welcome,welcome,welcome!&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="Python知识点（二）-运算符和表达式"><a href="#Python知识点（二）-运算符和表达式" class="headerlink" title="Python知识点（二）  运算符和表达式"></a>Python知识点（二）  运算符和表达式</h2><blockquote><p>“+”运算符不支持不同内置类型的对象之间相加或连接。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="string">&#x27;A&#x27;</span> + <span class="number">1</span>                            <span class="comment">#不支持字符与数字相加，抛出异常</span></span><br><span class="line">TypeError: can only concatenate <span class="built_in">str</span> (<span class="keyword">not</span> <span class="string">&quot;int&quot;</span>) to <span class="built_in">str</span></span><br></pre></td></tr></table></figure><blockquote><p>“<em>”运算符 §列表、字符串或元组等类型变量与整数进行“</em>”运算时，表示<strong>对内容进行重复</strong>并返回重复后的新对象。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="string">&#x27;a&#x27;</span> * <span class="number">10</span>                    <span class="comment">#字符串重复</span></span><br><span class="line"><span class="string">&#x27;aaaaaaaaaa&#x27;</span></span><br><span class="line"> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] * <span class="number">3</span>                 <span class="comment">#列表重复</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"> (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>) * <span class="number">3</span>                 <span class="comment">#元组重复</span></span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><blockquote><p>“&#x2F;”和“&#x2F;&#x2F;”分别表示除法和整除运算。</p></blockquote><blockquote><p>同一性测试运算符（identity comparison）is用来测试两个对象是否引用同一个地址，如果是则返回True，否则返回False。<strong>如果两个对象引用了同一个对象，二者具有相同的内存地址。</strong></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> 3 is 3</span><br><span class="line">True</span><br><span class="line"></span><br><span class="line"> x = [300, 300, 300]</span><br><span class="line"> x[0] is x[1]        #基于值的内存管理，同一个值在内存中只有一份</span><br><span class="line">True</span><br><span class="line"></span><br><span class="line"> x = [1, 2, 3]</span><br><span class="line"> y = [1, 2, 3]</span><br><span class="line"> x is y              #上面形式创建的x和y不是同一个列表对象</span><br><span class="line">False</span><br></pre></td></tr></table></figure><blockquote><p>Python不支持++和–运算符，只是两个连续的加号和减号。</p></blockquote><blockquote><p>and和or具有惰性求值特点，只计算必须计算的表达式。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span>&gt;<span class="number">5</span> <span class="keyword">or</span> a&gt;<span class="number">3</span>           <span class="comment"># 3&gt;5的值为False，所以需要计算后面表达式</span></span><br><span class="line">NameError: name <span class="string">&#x27;a&#x27;</span> <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>&lt;<span class="number">5</span> <span class="keyword">or</span> a&gt;<span class="number">3</span>           <span class="comment">#3&lt;5的值为True，不需要计算后面表达式</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><h2 id="Python知识点（三）-常用内置函数"><a href="#Python知识点（三）-常用内置函数" class="headerlink" title="Python知识点（三）  常用内置函数"></a>Python知识点（三）  常用内置函数</h2><ol><li><h5 id="eval"><a href="#eval" class="headerlink" title="eval()"></a>eval()</h5><blockquote><p>去掉参数最外侧引号并执行余下语句的函数</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">eval</span>(<span class="string">&quot;1&quot;</span>)</span><br><span class="line"><span class="number">1</span> </span><br><span class="line"></span><br><span class="line"><span class="built_in">eval</span>(<span class="string">&quot;1+2&quot;</span>)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">eval</span>(<span class="string">&#x27;print(&quot;Hello&quot;)&#x27;</span>)</span><br><span class="line">Hello</span><br></pre></td></tr></table></figure></li><li><p><strong>divmod(x, y)</strong></p><blockquote><p>计算整商和余数，返回元组(x&#x2F;&#x2F;y, x%y)</p></blockquote></li><li><p><strong>range()</strong></p><blockquote><p>语法格式为range([start,] end [, step] )，返回具有惰性求值特点的range对象，其中包含<strong>左闭右开区间</strong>[start,end)内以step为步长的整数。</p></blockquote></li><li><p>*<em>map(func, <em>iterables)</em></em></p><blockquote><p>把一个可调用对象func依次映射到一个或多个可迭代对象的每个元素上，并返回一个可迭代的map对象作为结果，map对象中每个元素是原可迭代对象中元素经过可调用对象func处理后的结果。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">x, y</span>):            <span class="comment">#可以接收2个参数的函数</span></span><br><span class="line">    <span class="keyword">return</span> x+y</span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>(<span class="built_in">map</span>(add, <span class="built_in">range</span>(<span class="number">5</span>), <span class="built_in">range</span>(<span class="number">5</span>,<span class="number">10</span>)))  <span class="comment">#把双参数函数映射到两个序列上</span></span><br><span class="line"></span><br><span class="line">[<span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">13</span>]  <span class="comment"># 输出结果</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><strong>sorted(key&#x3D;None,reverse&#x3D;False)</strong></p><blockquote><p>返回排序后的列表，参数key用来指定排序规则或依据，参数reverse用来指定升序或降序，默认为升序。</p></blockquote></li><li><p><strong>filter(function or None, iterable)</strong></p><blockquote><p>将一个单参数可调用对象作用到一个可迭代对象上，返回其中使得可调用对象返回值等价于True的那些元素组成的filter对象，如果指定filter()函数第一个参数为None，则返回可迭代对象中等价于True的元素。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">seq = [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;x41&#x27;</span>, <span class="string">&#x27;?!&#x27;</span>, <span class="string">&#x27;***&#x27;</span>]</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> x.isalnum()              <span class="comment">#测试是否为字母或数字</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">filter</span>(func, seq)                   <span class="comment">#返回filter对象</span></span><br><span class="line">&lt;<span class="built_in">filter</span> <span class="built_in">object</span> at <span class="number">0x000000000305D898</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>(<span class="built_in">filter</span>(func, seq))             <span class="comment">#把filter对象转换为列表</span></span><br><span class="line">[<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;x41&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>(<span class="built_in">filter</span>(<span class="built_in">str</span>.isalnum, seq))      <span class="comment">#等价的用法</span></span><br><span class="line">[<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;x41&#x27;</span>]</span><br><span class="line"></span><br><span class="line">data = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">20</span>))</span><br><span class="line">filterObject = <span class="built_in">filter</span>(<span class="keyword">lambda</span> x:x%<span class="number">2</span>==<span class="number">1</span>, data)    <span class="comment">#过滤，只留下所有奇数</span></span><br><span class="line"></span><br><span class="line">filterObject</span><br><span class="line">&lt;<span class="built_in">filter</span> <span class="built_in">object</span> at <span class="number">0x000001D602B85828</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="number">3</span> <span class="keyword">in</span> filterObject            <span class="comment">#3以及3之前的元素都访问过了</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>(filterObject)           <span class="comment">#现在所有元素都访问过了</span></span><br><span class="line">[<span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">15</span>, <span class="number">17</span>, <span class="number">19</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>(filterObject)           <span class="comment">#filterObject中不再包含任何元素，因为filter对象具有惰性求值的特点</span></span><br><span class="line">[]</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><strong>reduce(function, sequence[, initial])</strong></p><blockquote><p>可以将一个接收2个参数的可调用对象以<strong>迭代累积</strong>的方式从左到右依次作用到一个可迭代对象的所有元素上，并且允许指定一个初始值。在Python 3.x中reduce()不是内置函数，需要从标准库functools中导入再使用。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line">seq = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>))     <span class="comment"># 数据</span></span><br><span class="line">reduce(<span class="keyword">lambda</span> x, y: x+y, seq)  <span class="comment"># 累加并返回结果 输出结果 45</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="D:\Savior\Documents\大三\计算机网络\期末复习\image-20230116211838466.png" alt="image-20230116211838466"></p></li><li><p><strong>round(number, ndigits&#x3D;None)</strong></p><blockquote><p>对number进行四舍五入，最终结果保留ndigits位小数。</p></blockquote></li><li><p><strong>enumerate()</strong></p><blockquote><p>函数用来枚举可迭代对象中的元素，返回可迭代的enumerate对象，其中每个元素都是包含索引和值的元组。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>(<span class="built_in">enumerate</span>(<span class="string">&#x27;abcd&#x27;</span>))            <span class="comment">#枚举字符串中的元素</span></span><br><span class="line">[(<span class="number">0</span>, <span class="string">&#x27;a&#x27;</span>), (<span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>), (<span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>), (<span class="number">3</span>, <span class="string">&#x27;d&#x27;</span>)]</span><br></pre></td></tr></table></figure></li><li><p><strong>bin()、oct()、hex()</strong></p></li></ol><blockquote><p>将**<u>整数</u>**转换为二进制、八进制和十六进制形式。</p></blockquote><ol start="11"><li><p><strong>zip()</strong></p><blockquote><p>函数用来把多个可迭代对象中对应位置上的元素组合到一起，返回一个可迭代的zip对象，其中每个元素都是包含原来的多个可迭代对象对应位置上元素的元组，如同拉拉链一样。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>(<span class="built_in">zip</span>(<span class="string">&#x27;abcd&#x27;</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]))  <span class="comment"># 输出结果  [(&#x27;a&#x27;, 1), (&#x27;b&#x27;, 2), (&#x27;c&#x27;, 3)]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>(<span class="built_in">zip</span>(<span class="string">&#x27;123&#x27;</span>, <span class="string">&#x27;abc&#x27;</span>, <span class="string">&#x27;,.!&#x27;</span>))  <span class="comment"># 输出结果  [(&#x27;1&#x27;, &#x27;a&#x27;, &#x27;,&#x27;), (&#x27;2&#x27;, &#x27;b&#x27;, &#x27;.&#x27;), (&#x27;3&#x27;, &#x27;c&#x27;, &#x27;!&#x27;)]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以看到结果列表中的每个成员都是元组类型</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>最后注意：</p><blockquote><p>map、filter、enumerate、zip等对象不仅具有惰性求值的特点，还有另外一个特点：访问过的元素不可再次访问。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="built_in">map</span>(<span class="built_in">str</span>, <span class="built_in">range</span>(<span class="number">10</span>))   </span><br><span class="line"><span class="built_in">list</span>(x)</span><br><span class="line">[<span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;9&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>(x)</span><br><span class="line">[]   <span class="comment"># 失效了</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h2 id="阶段练习"><a href="#阶段练习" class="headerlink" title="阶段练习"></a>阶段练习</h2><p>用户输入一个三位自然数，计算并输出其佰位、十位和个位上的数字。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一种</span></span><br><span class="line">x = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;请输入一个三位数：&#x27;</span>))</span><br><span class="line">a, b = <span class="built_in">divmod</span>(x, <span class="number">100</span>)</span><br><span class="line">b, c = <span class="built_in">divmod</span>(b, <span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(a, b, c)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二种</span></span><br><span class="line">x = <span class="built_in">input</span>(<span class="string">&#x27;请输入一个三位数：&#x27;</span>)</span><br><span class="line">a, b, c = <span class="built_in">map</span>(<span class="built_in">int</span>, x)</span><br><span class="line"><span class="built_in">print</span>(a, b, c)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第三种  不限位数</span></span><br><span class="line">x = <span class="built_in">input</span>(<span class="string">&#x27;请输入一个n位自然数：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(*<span class="built_in">map</span>(<span class="built_in">int</span>, x))</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>任意输入三个英文单词，按字典顺序输出。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="built_in">input</span>(<span class="string">&#x27;x,y,z=&#x27;</span>)</span><br><span class="line">x, y, z = <span class="built_in">sorted</span>(s.split(<span class="string">&#x27;,&#x27;</span>))   <span class="comment"># 逗号分隔</span></span><br><span class="line"><span class="built_in">print</span>(x, y, z)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Python知识点（四）-Python序列"><a href="#Python知识点（四）-Python序列" class="headerlink" title="Python知识点（四）  Python序列"></a>Python知识点（四）  Python序列</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><img src="D:\Savior\Documents\大三\计算机网络\期末复习\image-20230119150122468.png" alt="image-20230119150122468"></p><h3 id="列表增加"><a href="#列表增加" class="headerlink" title="列表增加"></a>列表增加</h3><blockquote><p>使用列表对象的extend()方法可以将另一个可迭代对象的所有元素添加至该列表对象尾部。通过extend()方法来增加列表元素也不改变其内存首地址，属于<strong>原地操作</strong>。</p></blockquote><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">aList = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br><span class="line">aList.extend([<span class="number">11</span>,<span class="number">13</span>])</span><br><span class="line">aList</span><br><span class="line">[<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">13</span>]</span><br><span class="line"></span><br><span class="line">aList.extend((<span class="number">15</span>,<span class="number">17</span>))</span><br><span class="line">aList</span><br><span class="line">[<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">15</span>, <span class="number">17</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>使用列表对象的insert()方法将元素添加至列表的指定位置。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">aList.insert(<span class="number">3</span>, <span class="number">6</span>)                <span class="comment">#在下标为3的位置插入元素6</span></span><br><span class="line">aList</span><br><span class="line">[<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">15</span>, <span class="number">17</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>当使用*运算符将包含列表的列表重复并创建新列表时，并不是复制子列表值，而是复制已有元素的引用。因此，当修改其中一个值时，相应的引用也会被修改。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">x = [[<span class="literal">None</span>] * <span class="number">2</span>] * <span class="number">3</span></span><br><span class="line">x</span><br><span class="line">[[<span class="literal">None</span>, <span class="literal">None</span>], [<span class="literal">None</span>, <span class="literal">None</span>], [<span class="literal">None</span>, <span class="literal">None</span>]]</span><br><span class="line"></span><br><span class="line">x[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">5</span></span><br><span class="line">x</span><br><span class="line">[[<span class="number">5</span>, <span class="literal">None</span>], [<span class="number">5</span>, <span class="literal">None</span>], [<span class="number">5</span>, <span class="literal">None</span>]]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="列表删除"><a href="#列表删除" class="headerlink" title="列表删除"></a>列表删除</h3><blockquote><p>del命令</p><p>pop()方法删除并返回<em>指定位置</em>（默认为最后一个）</p><p>remove()方法删除首次出现的指定元素，如果列表中不存在要删除的元素，则抛出异常。</p><p>注：列表有自动内存管理功能。在删除列表元素时，Python会自动对列表内存进行收缩并移动列表元素以保证所有元素之间没有空隙，增加列表元素时也会自动扩展内存并对元素进行移动以保证元素之间没有空隙。每当插入或删除一个元素之后，该元素位置后面所有元素的索引就都改变了。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">正确的删除代码：</span><br><span class="line">x = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(x)-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>):         <span class="comment">#从后往前删</span></span><br><span class="line">    <span class="keyword">if</span> x[i]==<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">del</span> x[i]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="列表切片"><a href="#列表切片" class="headerlink" title="列表切片"></a>列表切片</h3><blockquote><p>切片返回的是浅复制。所谓浅复制，是指生成一个新的列表，并且把原列表中所选元素的引用都复制到新列表中。如果原列表中只包含<strong>整数、实数、复数等基本类型或元组、字符串这样的不可变类型</strong>的数据，一般是没有问题的。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">aList = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>]</span><br><span class="line">bList = aList[::]                 <span class="comment">#切片，浅复制</span></span><br><span class="line">aList == bList                    <span class="comment">#两个列表的元素完全一样</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line">aList <span class="keyword">is</span> bList                    <span class="comment">#但不是同一个对象</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="built_in">id</span>(aList) == <span class="built_in">id</span>(bList)            <span class="comment">#内存地址不一样</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line">bList[<span class="number">1</span>] = <span class="number">8</span>                      <span class="comment">#修改其中一个不会影响另一个</span></span><br><span class="line">bList</span><br><span class="line">[<span class="number">3</span>, <span class="number">8</span>, <span class="number">7</span>]</span><br><span class="line">aList</span><br><span class="line">[<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>]</span><br></pre></td></tr></table></figure><blockquote><p>如果原列表中包含列表之类的可变数据类型，由于浅复制时只是把子列表的引用复制到新列表中，这样的话修改任何一个都会影响另外一个。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">aList = [<span class="number">3</span>, [<span class="number">5</span>], <span class="number">7</span>]        <span class="comment">#列表aList中包含可变的列表对象</span></span><br><span class="line">bList = aList[:]           <span class="comment">#切片</span></span><br><span class="line">bList[<span class="number">1</span>].append(<span class="number">6</span>)         <span class="comment">#调用子列表的append()方法，这个方法是原地操作的</span></span><br><span class="line"></span><br><span class="line">bList</span><br><span class="line">[<span class="number">3</span>, [<span class="number">5</span>, <span class="number">6</span>], <span class="number">7</span>]</span><br><span class="line"></span><br><span class="line">aList                      <span class="comment">#aList受到影响</span></span><br><span class="line">[<span class="number">3</span>, [<span class="number">5</span>, <span class="number">6</span>], <span class="number">7</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>标准库copy中的deepcopy()函数实现深复制。所谓深复制，是指对原列表中的元素进行递归，把所有的值都复制到新列表中，对嵌套的子列表不再是复制引用。新列表和原列表是互相独立，<strong>修改任何一个都不会影响另外一个</strong>。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">aList = [<span class="number">3</span>, [<span class="number">5</span>], <span class="number">7</span>]</span><br><span class="line"><span class="keyword">import</span> copy</span><br><span class="line">bList = copy.deepcopy(aList) <span class="comment">#深赋值，递归复制，直到遇到可哈希对象</span></span><br><span class="line">                                 <span class="comment">#aList和bList完全独立，互相不影响</span></span><br><span class="line">aList == bList</span><br><span class="line"><span class="literal">True</span></span><br><span class="line">aList <span class="keyword">is</span> bList</span><br><span class="line"><span class="literal">False</span></span><br><span class="line">bList[<span class="number">1</span>].append(<span class="number">6</span>)           <span class="comment">#修改bList不会影响aList</span></span><br><span class="line">bList</span><br><span class="line">[<span class="number">3</span>, [<span class="number">5</span>, <span class="number">6</span>], <span class="number">7</span>]</span><br><span class="line">aList</span><br><span class="line">[<span class="number">3</span>, [<span class="number">5</span>], <span class="number">7</span>]</span><br></pre></td></tr></table></figure><p>以下这张图深刻地解释了切片复制的原理：不可变类型数据不影响（指向不同的内存地址），可变类型数据影响（指向相同的内存地址）</p><p><img src="D:\Savior\Documents\大三\计算机网络\期末复习\image-20230119162208000.png" alt="image-20230119162208000"></p><h3 id="列表排序"><a href="#列表排序" class="headerlink" title="列表排序"></a>列表排序</h3><blockquote><p>sort()方法进行原地排序</p><p>sorted()对列表进行排序并返回<u>新列表</u>。</p><p>reverse()方法将元素原地逆序。</p><p>reversed()对列表元素进行逆序排列并返回<u>迭代器</u>对象。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">aList = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">15</span>, <span class="number">17</span>]</span><br><span class="line">aList.sort()                          <span class="comment">#默认是升序排序</span></span><br><span class="line">aList.sort(reverse=<span class="literal">True</span>)              <span class="comment">#降序排序</span></span><br><span class="line">aList.sort(key=<span class="keyword">lambda</span> x:<span class="built_in">len</span>(<span class="built_in">str</span>(x)))  <span class="comment">#按转换成字符串的长度排序</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">sorted</span>(aList)                          <span class="comment">#升序排序，默认是按字母的ascii编码顺序</span></span><br><span class="line"><span class="built_in">sorted</span>(aList,reverse=<span class="literal">True</span>)             <span class="comment">#降序排序</span></span><br><span class="line"></span><br><span class="line">aList.reverse()            <span class="comment"># 原地逆序</span></span><br><span class="line"></span><br><span class="line">newList = <span class="built_in">reversed</span>(aList)            <span class="comment">#返回reversed对象</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> newList:</span><br><span class="line">    <span class="built_in">print</span>(i, end=<span class="string">&#x27; &#x27;</span>)                  <span class="comment">#输出结果  17 15 13 11 9 7 6 5 4 3</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure><h3 id="用于序列操作的常用内置函数"><a href="#用于序列操作的常用内置函数" class="headerlink" title="用于序列操作的常用内置函数"></a>用于序列操作的常用内置函数</h3><p>any(iterable)</p><blockquote><p>参数<br>        iterable – 元组或列表<br>返回值<br>        如果都为空、0、false，则返回false，如果不都为空、0、false，则返回true。有点类似于或运算（or）</p></blockquote><p>all(iterable)</p><blockquote><p>参数<br>iterable – 元组或列表。<br>返回值<br>如果iterable的所有元素不为0、’’、False或者iterable为空，all(iterable)返回True，否则返回False；</p><p>注意：<strong>空元组、空列表返回值为True</strong>，这里要特别注意。</p></blockquote><p>其他</p><blockquote><p>len(列表)：返回列表中的元素个数</p><p>max(列表)、 min(列表)：返回列表中的最大或最小元素</p><p>sum(列表)：对列表的元素进行求和运算</p><p>zip()函数返回可迭代的zip对象</p><p>enumerate(列表):枚举列表元素，返回枚举对象，其中每个元素为包含下标和值的元组。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">aList = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">bList = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">cList = <span class="built_in">zip</span>(aList, bList)         <span class="comment">#返回zip对象</span></span><br><span class="line">cList</span><br><span class="line">&lt;<span class="built_in">zip</span> <span class="built_in">object</span> at <span class="number">0x0000000003728908</span>&gt;</span><br><span class="line"><span class="built_in">list</span>(cList)                       <span class="comment">#把zip对象转换成列表</span></span><br><span class="line">[(<span class="number">1</span>, <span class="number">4</span>), (<span class="number">2</span>, <span class="number">5</span>), (<span class="number">3</span>, <span class="number">6</span>)]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="string">&#x27;abcdef&#x27;</span>):</span><br><span class="line">    <span class="built_in">print</span>(item)</span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">(<span class="number">0</span>, <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">(<span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">(<span class="number">3</span>, <span class="string">&#x27;d&#x27;</span>)</span><br><span class="line">(<span class="number">4</span>, <span class="string">&#x27;e&#x27;</span>)</span><br><span class="line">(<span class="number">5</span>, <span class="string">&#x27;f&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络期末复习</title>
      <link href="/2023/01/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"/>
      <url>/2023/01/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="第-1-章"><a href="#第-1-章" class="headerlink" title="第 1 章"></a>第 1 章</h2><h2 id="第-2-章-物理层（P53）"><a href="#第-2-章-物理层（P53）" class="headerlink" title="第 2 章  物理层（P53）"></a>第 2 章  物理层（P53）</h2><p>单位为比特</p><h2 id="第-3-章-数据链路层（P74）"><a href="#第-3-章-数据链路层（P74）" class="headerlink" title="第 3 章 数据链路层（P74）"></a>第 3 章 数据链路层（P74）</h2><p>数据链路层的三个基本问题：封装成帧、透明传输、差错检测，单位为帧</p><h2 id="第-4-章-网络层（P110）"><a href="#第-4-章-网络层（P110）" class="headerlink" title="第 4 章 网络层（P110）"></a>第 4 章 网络层（P110）</h2><p>单位为分组</p><h2 id="第-5-章-运输层（P136）"><a href="#第-5-章-运输层（P136）" class="headerlink" title="第 5 章 运输层（P136）"></a>第 5 章 运输层（P136）</h2><p>可靠传输、流量控制、拥塞控制，单位为报文段</p><h3 id="一、运输层的端口号和套接字的意义"><a href="#一、运输层的端口号和套接字的意义" class="headerlink" title="一、运输层的端口号和套接字的意义"></a>一、运输层的端口号和套接字的意义</h3><p>端口是应用层的各种协议进程与运输实体进行层间交互的地点。</p><p>TCP用主机的IP地址加上主机上的端口号作为TCP连接的端点，叫作套接字（socket）  （IP地址：端口号）来表示。</p><p><img src="D:\Savior\Documents\大三\计算机网络\期末复习\image-20230114230005375.png" alt="image-20230114230005375"></p><p><img src="D:\Savior\Documents\大三\计算机网络\期末复习\image-20230114230046659.png" alt="image-20230114230046659"></p><p><img src="D:\Savior\Documents\大三\计算机网络\期末复习\image-20230114230105768.png" alt="image-20230114230105768"></p><h3 id="二、UDP和TCP的对比"><a href="#二、UDP和TCP的对比" class="headerlink" title="二、UDP和TCP的对比"></a>二、UDP和TCP的对比</h3><p><img src="D:\Savior\Documents\大三\计算机网络\期末复习\image-20230114230126356.png" alt="image-20230114230126356"></p><h3 id="三、流量控制"><a href="#三、流量控制" class="headerlink" title="三、流量控制"></a>三、流量控制</h3><p><img src="D:\Savior\Documents\大三\计算机网络\期末复习\image-20230114230138781.png" alt="image-20230114230138781"></p><p><img src="D:\Savior\Documents\大三\计算机网络\期末复习\image-20230114230150946.png" alt="image-20230114230150946"></p><p><img src="D:\Savior\Documents\大三\计算机网络\期末复习\image-20230114230204434.png" alt="image-20230114230204434"></p><h3 id="四、可靠传输"><a href="#四、可靠传输" class="headerlink" title="四、可靠传输"></a>四、可靠传输</h3><p><img src="D:\Savior\Documents\大三\计算机网络\期末复习\image-20230115145333407.png" alt="image-20230115145333407"></p><h5 id="停止-等待协议"><a href="#停止-等待协议" class="headerlink" title="停止-等待协议"></a>停止-等待协议</h5><p><img src="D:\Savior\Documents\大三\计算机网络\期末复习\image-20230115150939273.png" alt="image-20230115150939273"></p><p><img src="D:\Savior\Documents\大三\计算机网络\期末复习\image-20230115151729196.png" alt="image-20230115151729196"></p><p><img src="D:\Savior\Documents\大三\计算机网络\期末复习\image-20230115151757295.png" alt="image-20230115151757295"></p><h5 id="后退N帧协议"><a href="#后退N帧协议" class="headerlink" title="后退N帧协议"></a>后退N帧协议</h5><p><img src="D:\Savior\Documents\大三\计算机网络\期末复习\image-20230115163558383.png" alt="image-20230115163558383"></p><p><img src="D:\Savior\Documents\大三\计算机网络\期末复习\image-20230115162943337.png" alt="image-20230115162943337"></p><p><img src="D:\Savior\Documents\大三\计算机网络\期末复习\image-20230115163450863.png" alt="image-20230115163450863"></p><h5 id="选择重传协议"><a href="#选择重传协议" class="headerlink" title="选择重传协议"></a>选择重传协议</h5><p><img src="D:\Savior\Documents\大三\计算机网络\期末复习\image-20230115171035189.png" alt="image-20230115171035189"></p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p><img src="D:\Savior\Documents\大三\计算机网络\期末复习\image-20230115170847904.png" alt="image-20230115170847904"></p><p>确认号指的是接收方想要接收的报文段的序号。</p><h3 id="五、拥塞控制"><a href="#五、拥塞控制" class="headerlink" title="五、拥塞控制"></a>五、拥塞控制</h3><p><img src="D:\Savior\Documents\大三\计算机网络\期末复习\image-20230119103310461.png" alt="image-20230119103310461"></p><p><img src="D:\Savior\Documents\大三\计算机网络\期末复习\image-20230119112042661.png" alt="image-20230119112042661"></p><p><img src="D:\Savior\Documents\大三\计算机网络\期末复习\image-20230119112131896.png" alt="image-20230119112131896"></p><h3 id="六、TCP的运输连接管理-P134"><a href="#六、TCP的运输连接管理-P134" class="headerlink" title="六、TCP的运输连接管理(P134)"></a>六、TCP的运输连接管理(P134)</h3><blockquote><p>TCP运输连接的三个阶段：</p></blockquote><p><img src="D:\Savior\Documents\大三\计算机网络\期末复习\image-20230119091909624.png" alt="image-20230119091909624"></p><p><img src="D:\Savior\Documents\大三\计算机网络\期末复习\image-20230119092914852.png" alt="image-20230119092914852"></p><h3 id="七、TCP-的三次握手，四次挥手机制"><a href="#七、TCP-的三次握手，四次挥手机制" class="headerlink" title="七、TCP 的三次握手，四次挥手机制"></a>七、TCP 的三次握手，四次挥手机制</h3><blockquote><p>TCP客户端进程主动打开或关闭，TCP服务端进程被动打开（监听）或关闭。</p></blockquote><p><img src="D:\Savior\Documents\大三\计算机网络\期末复习\image-20230119092647193.png" alt="image-20230119092647193"></p><blockquote><p>如上图，二次握手的话，在结尾时客户没有对TCP连接请求进行确认，没有任何回应，导致服务器资源浪费（白白等待着客户发送数据）。</p></blockquote><p><img src="D:\Savior\Documents\大三\计算机网络\期末复习\image-20230119143818139.png" alt="image-20230119143818139"></p><blockquote><p>再如上图，三次握手，如果使用三报文握手，那么B在收到A发送的陈旧的SYN报文段后，就向A发送SYN报文段，选择自己的序号seq&#x3D;y，并确认收到A的SYN报文段，其确认号ack&#x3D;x+1。当A收到B的SYN报文段时，从确认号就可得知不应当理睬这个SYN报文段（因为A现在并没有发送sq&#x3D;x的SYN报文段)。这时，A发送复位报文段。在这个报文段中，RST&#x3D;1，ACK&#x3D;1，其确认号ack&#x3D;y+1。我们注意到，虽然A拒绝了TCP连接的建立（发送了复位报文段），但对B发送的SYN报文段还是确认收到了。</p><p><strong>B收到A的RST报文段后</strong>，就知道不能建立TCP连接，不会等待A发送数据了，就不会白白等待了。</p></blockquote><p><img src="D:\Savior\Documents\大三\计算机网络\期末复习\image-20230119093607814.png" alt="image-20230119093607814"></p><p><img src="D:\Savior\Documents\大三\计算机网络\期末复习\image-20230119093654948.png" alt="image-20230119093654948"></p><p><img src="D:\Savior\Documents\大三\计算机网络\期末复习\image-20230119093803247.png" alt="image-20230119093803247"></p><h2 id="第-6-章-应用层"><a href="#第-6-章-应用层" class="headerlink" title="第 6 章 应用层"></a>第 6 章 应用层</h2><p><img src="D:\Savior\Documents\大三\计算机网络\期末复习\image-20230119102635861.png" alt="image-20230119102635861"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/01/18/%E7%BD%91%E7%AB%99%E5%BC%80%E5%8F%91/"/>
      <url>/2023/01/18/%E7%BD%91%E7%AB%99%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h2 id="网站开发基础"><a href="#网站开发基础" class="headerlink" title="网站开发基础"></a>网站开发基础</h2><h4 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h4><p>域名、服务器、搭建网站环境。</p><h4 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h4><p>【1】WordPress（开源建站系统）<br>可用于建造个人博客，企业官网，电商平台<br>特点：傻瓜式、多主题、插件丰富。<br><a href="https://cn.wordpress.org/">https://cn.wordpress.org/</a></p><p>【2】docsify（文档站点生成器）<br>特点：使用简单，可装插件、响应式。<br><a href="https://docsify.js.org/#/">https://docsify.js.org/#/</a></p><p>【3】dumi（文档站点生成器）<br>适合项目、产品的官网<br>特点：使用简单，专为组件开发场景而生<br><a href="https://d.umijs.org/">https://d.umijs.org/</a></p><p>【4】imgcook<br>根据设计稿一键智能生成代码<br>特点：傻瓜式操作，随意修改，AI生成代码<br><a href="https://www.imgcook.com/">https://www.imgcook.com/</a></p><p>【5】ant design landing<br>网站首页生成器<br>特点：模板丰富，可视化编辑网页元素，可一键上传网站，不需要购买服务器、域名等。<br><a href="https://ant-design-landing.gitee.io/index-cn">https://ant-design-landing.gitee.io/index-cn</a></p><p>【6】TX兔小巢<br>产品反馈平台<br>特点：免费，一键生成网站反馈社区<br><a href="https://txc.qq.com/">https://txc.qq.com/</a></p><p>【7】百度统计<br>网站数据统计<br>特点：多场景统计分析，简单易用<br><a href="https://tongji.baidu.com/web/welcome/login">https://tongji.baidu.com/web/welcome/login</a></p><p>【8】Discuz Q<br>PC端开源社区软件<br>特点：开源，功能丰富<br><a href="https://discuz.chat/?categoryId=all&sequence=0">https://discuz.chat/?categoryId=all&amp;sequence=0</a></p><p>【9】tailwindcss</p><p>UI框架，提供现成具体好看的css样式，帮助我们快速构建现代化网站</p><p><a href="https://www.tailwindcss.cn/">https://www.tailwindcss.cn/</a></p><h2 id="班级网站需求分析"><a href="#班级网站需求分析" class="headerlink" title="班级网站需求分析"></a>班级网站需求分析</h2><p>根据调查，必须让同学们有收获，或者说有正反馈，这是能让同学们关注并使用网站的第一步。</p><ol><li>班级简介</li><li>班级通知、布置作业、课程表</li><li>留言板（提建议）</li><li>班级事迹、文体活动</li><li>思想建设</li><li>新鲜事</li><li>友情链接（学校网站、好用的工具）</li><li>学校风光</li><li>设置一个点歌的小插件，最好能听一些付费的歌曲。</li><li>百度搜索功能</li><li>时间显示功能</li><li>计算综测分</li><li>点名统计</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/01/18/%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E8%AE%BE%E8%AE%A1/"/>
      <url>/2023/01/18/%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h2><h3 id="Load-Balancing-负载均衡"><a href="#Load-Balancing-负载均衡" class="headerlink" title="Load Balancing  负载均衡"></a>Load Balancing  负载均衡</h3><p>用来保护Web server，把请求打到应该打到的服务上（现在大厂，网关+RPC）</p><p>当用户登录某一网页时，浏览器通过DNS服务器域名解析后拿到的IP可能是某个Load Balancer的IP地址， 而不是web server的IP地址。用户发送的请求通过Load Balancer 均匀地分发给web server进行处理。</p><p>常见算法：比如round robin（轮询调度）, least connection（最小连接数法）, hashing（哈希散列）等。。。。 </p><p>High Scalability  （高扩展） ：扩容，Load Balancer下添加更多的web server，来服务更多的用户。</p><p>High Availability （高可用）：Load Balancer持续监听每台web server的状态是否OK，确保将用户请求发给状态OK的web server，挂机的web server就拜拜了，保证服务不中断。</p><p>有小伙伴还会问那Load Balancer也挂掉了呢？</p><p>那Load Balancer肯定也有备份的啦，一个 Load balancer 挂掉，或者是 BGP 发布取消，备份的 Load balancer可以马上接管流量，继续进行响应。</p><p><img src="D:\Savior\Documents\大三\计算机网络\期末复习\image-20230118183913342.png"></p><h3 id="Database-Design-数据库设计"><a href="#Database-Design-数据库设计" class="headerlink" title="Database Design  数据库设计"></a>Database Design  数据库设计</h3><p>一个是设计data model数据模型</p><p>另一个是数据库的选型</p><p>ps：两者互相关联，因为数据库选型的一个重要参数就是数据模型</p><p>eg :  YouTube de metadata  –&gt; mysql、pg</p><p>电商3网站的产品目录，什么鬼东西都有 –&gt; NoSQL (Cassandra. HBase. MongoDB</p><p>等)</p><p>关系型数据库误区，说关系型数据库不能Scalability，大规模化存储数据，听着有点怪怪的，我们学习数据库都有接触到分库分表、docker &amp;&amp; K8s承载数据库集群，现在大厂的还有云数据库等等。。。</p><p>up提到YouTube的分布式MySQL方案（Vitess）倒是不错，可以看看。</p><p>关系型数据库都需要 data partitioning（数据分区、分片） 的方案，都需要选择 partitioning key（设计构造好分区键值）</p><h3 id="Caching-存储中间件（Memcache、Redis）"><a href="#Caching-存储中间件（Memcache、Redis）" class="headerlink" title="Caching 存储中间件（Memcache、Redis）"></a>Caching 存储中间件（Memcache、Redis）</h3><p>memcache是一套分布式的高速缓存系统</p><h3 id="CDN（Content-Delivery-Network内容分发网络）"><a href="#CDN（Content-Delivery-Network内容分发网络）" class="headerlink" title="CDN（Content Delivery Network内容分发网络）"></a>CDN（Content Delivery Network内容分发网络）</h3><p><img src="D:\Savior\Documents\大三\计算机网络\期末复习\image-20230118184031266.png" alt="image-20230118184031266"></p><h3 id="Asynchronous-processing-异步处理"><a href="#Asynchronous-processing-异步处理" class="headerlink" title="Asynchronous processing 异步处理"></a>Asynchronous processing 异步处理</h3><p>先来说说同步处理 (synchronous processing)，如果一个任务是同步处理，那调用者必须等到任务结束，才能继续后面的工作。比如，</p><p>如果一个任务是异步执行的，那么任务的调用者，不用等到任务结束。</p><p>常规解决方案：解耦（MQ）</p>]]></content>
      
      
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title></title>
      <link href="/Gallery/index.html"/>
      <url>/Gallery/index.html</url>
      
        <content type="html"><![CDATA[<hr><h2 id="title-照片date-2023-1-29-14-52-00"><a href="#title-照片date-2023-1-29-14-52-00" class="headerlink" title="title: 照片date: 2023-1-29 14:52:00"></a>title: 照片<br>date: 2023-1-29 14:52:00</h2>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>分类</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>关于</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/hobby/index.html"/>
      <url>/hobby/index.html</url>
      
        <content type="html"><![CDATA[<hr><h2 id="title-兴趣爱好date-2023-1-29-14-52-00"><a href="#title-兴趣爱好date-2023-1-29-14-52-00" class="headerlink" title="title: 兴趣爱好date: 2023-1-29 14:52:00"></a>title: 兴趣爱好<br>date: 2023-1-29 14:52:00</h2>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>友链</title>
      <link href="/link/index.html"/>
      <url>/link/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/movie/index.html"/>
      <url>/movie/index.html</url>
      
        <content type="html"><![CDATA[<hr><h2 id="title-电影date-2023-1-29-14-52-00"><a href="#title-电影date-2023-1-29-14-52-00" class="headerlink" title="title: 电影date: 2023-1-29 14:52:00"></a>title: 电影<br>date: 2023-1-29 14:52:00</h2>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>标签</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/music/index.html"/>
      <url>/music/index.html</url>
      
        <content type="html"><![CDATA[<hr><h2 id="title-音乐date-2023-1-29-14-52-00type-“music”"><a href="#title-音乐date-2023-1-29-14-52-00type-“music”" class="headerlink" title="title: 音乐date: 2023-1-29 14:52:00type: “music”"></a>title: 音乐<br>date: 2023-1-29 14:52:00<br>type: “music”</h2>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/custom.css"/>
      <url>/css/custom.css</url>
      
        <content type="html"><![CDATA[/* 侧边栏个人信息卡片动态渐变色 */#aside-content > .card-widget.card-info {    background: linear-gradient(      -45deg,      #e8d8b9,      #eccec5,      #a3e9eb,      #bdbdf0,      #eec1ea    );    box-shadow: 0 0 5px rgb(66, 68, 68);    position: relative;    background-size: 400% 400%;    -webkit-animation: Gradient 10s ease infinite;    -moz-animation: Gradient 10s ease infinite;    animation: Gradient 10s ease infinite !important;  }  @-webkit-keyframes Gradient {    0% {      background-position: 0% 50%;    }    50% {      background-position: 100% 50%;    }    100% {      background-position: 0% 50%;    }  }  @-moz-keyframes Gradient {    0% {      background-position: 0% 50%;    }    50% {      background-position: 100% 50%;    }    100% {      background-position: 0% 50%;    }  }  @keyframes Gradient {    0% {      background-position: 0% 50%;    }    50% {      background-position: 100% 50%;    }    100% {      background-position: 0% 50%;    }  }    /* 黑夜模式适配 */  [data-theme="dark"] #aside-content > .card-widget.card-info {    background: #191919ee;  }    /* 个人信息Follow me按钮 */  #aside-content > .card-widget.card-info > #card-info-btn {    background-color: #3eb8be;    border-radius: 8px;  }/* 公众号 Start */[data-theme='light'] #aside-content .card-widget#card-wechat {    background: #4093c9 !important;}#aside-content .card-widget#card-wechat {    background: var(--card-bg);    display: flex;    justify-content: center;    align-content: center;    padding: 0;    cursor: pointer !important;    border: none;    height: 110px;}/* 如果你设置了aside 的 mobile 为 false，记得放开下面这段注释；   如果你设置了aside 的 mobile 为 true ，不需要改动。 *//* @media screen and (max-width: 768px) {    #aside-content .card-widget#card-wechat {        display: none !important;    }} */@media screen and (min-width: 1300px) {    #aside-content .card-widget {        margin-top: 1rem;    }}#flip-wrapper {    -webkit-perspective: 1000;    perspective: 1000;    position: relative;    width: 235px;    height: 110px;    z-index: 1;}#flip-wrapper:hover #flip-content {    -webkit-transform: rotateY(180deg);    transform: rotateY(180deg);}#flip-content {    width: 100%;    height: 100%;    -webkit-transform-style: preserve-3d;    transform-style: preserve-3d;    transition: cubic-bezier(0, 0, 0, 1.29) 0.3s;}.face {    position: absolute;    width: 100%;    height: 100%;    -webkit-backface-visibility: hidden;    backface-visibility: hidden;    background: url(https://img.zhheo.com/i/2022/08/31/630efc6e3e794.png) center center no-repeat;    background-size: 100%;}.back.face {    display: block;    -webkit-transform: rotateY(180deg);    transform: rotateY(180deg);    box-sizing: border-box;    background: url(https://bu.dusays.com/2022/10/30/635e9c6a228a3.png) center center no-repeat;    background-size: 100%;}/* 公众号 End */]]></content>
      
    </entry>
    
    
  
</search>
